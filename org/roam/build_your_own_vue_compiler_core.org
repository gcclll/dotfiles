:PROPERTIES:
:ID:       5eff117f-92ba-490a-ba9c-e5f59e0cbe47
:END:
#+SETUPFILE:~/.gclrc/org/hugo_setup.org
#+HUGO_SLUG: build_your_own_vue_compiler_core
#+HTML_HEAD: <meta name="category" content="vue"/>
#+HTML_HEAD: <meta name="tags" content="compiler-core"/>
#+HTML_HEAD: <meta name="createdAt" content="2022-04-25 09:34:13"/>
#+PROPERTY: header-args -n -r :noweb no-export
#+TITLE: build your own vue compiler-core
<badge: GCCLL | Homepage | green | / | gnu-emacs | tinder>

#+begin_box Vue3 Compiler-core :background-color green

vue3 编译器核心模块 -> [[https://github.com/vuejs/core/blob/main/packages/compiler-core/src/index.ts][core/index.ts at main · vuejs/core]]

green:该模块主要实现将SFC文件编译成render函数，其实主要包含三个阶段

 1. ast parser 阶段, 将 SFC 中的 ~<template>~ 编译成 AST(抽象语法树)；
 2. transform 阶段，对 ast 的加工处理生成 codegenNode，比如：处理 ~for/if/on/bind~ 等指令；
 3. codegen 阶段，根据 ast 生成的 codegenNode 去解析拼凑出 render 函数代码，然后
    用 ~new Function(code)~ 生成 ~render~ 函数；

旧博客中的相关文章：

[[https://www.cheng92.com/vue/vue3-source-code-compiler-core-parse_ts/][Vue3.0 源码系列（二）编译器核心 - Compiler core 1: parse.ts - 若叶知秋]]

[[https://www.cheng92.com/vue/vue3-source-code-compiler-core-ast_ts/][Vue3.0 源码系列（二）编译器核心 - Compiler core 2: ast.ts - 若叶知秋]]

[[https://www.cheng92.com/vue/vue3-source-code-compiler-core-compile_ts/][Vue3.0 源码系列（二）编译器核心 - Compiler core 3: compile.ts - 若叶知秋]]

[[https://www.cheng92.com/vue/vue-mind-map-house-cc/][Vue3 源码头脑风暴之☞compiler-core - 若叶知秋]]

[[https://www.cheng92.com/vue/vue-mind-map-compiler-core-parser/][Vue3 源码头脑风暴之 2 ☞compiler-core - ast parser - 若叶知秋]]

[[https://www.cheng92.com/vue/vue-mind-map-compiler-core-transform-generate/][Vue3 源码头脑风暴之 3 ☞compiler-core - transform + codegen - 若叶知秋]]

文中测试用例均来自官方用例：[[https://github.com/vuejs/core/tree/main/packages/compiler-core/__tests__][core/packages/compiler-core/__tests__ at main · vuejs/core]]

<red:每个章节、函数或功能下面都有对应的官方的测试用例和其输出结果，建议根据用例去
学习了解每个特性和功能的实现、编译原理和最后结果。>

这个包代码量巨大所以这篇文章篇幅很长很长，不建议通篇阅读，应该根据[[cc-contents-table][这里]]的功能列表
按照自己想了解的内容去阅读。

red:浏览器测试请使用 [[/assets/tests/compiler-core.html][compiler-core.html]]
#+end_box
#+html: <br>

当前页面中关键信息表(带文内链接)

#+name: cc-contents-table
| [[transformIf][v-if]]    | [[transformFor][v-for]]  | [[transformOn][v-on]]   |
| [[transformSlotOutlet][<slot/>]] | [[buildSlots][v-slot]] | [[transformBind][v-bind]] |
| [[transformModel][v-model]] | [[transformOnce][v-once]] | [[transformMemo][v-memo]] |

* Global variables

与实际逻辑没什么关联的变量和函数。

#+begin_details 全局变量 :title-color green
#+name: globalVars
#+begin_src js -n -r
let __BROWSER__ = typeof window !== 'undefined'
let logs = {}, currentLogKey = 'cc'
<<debugUtils>>

let babelParser
if (!__BROWSER__) {
  babelParser = require(process.env.NODE_LIB + '/@babel/parser')
}
// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g
const decodeMap = { (ref:html-entities)
  gt: '>',
  lt: '<',
  amp: '&',
  apos: "'",
  quot: '"'
}

const EMPTY_OBJ = {}
const NO = () => false
const NOOP = () => {}
const locStub = {
  source: '',
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
}

const ConstantTypes = {
  NOT_CONSTANT: 0,
  CAN_SKIP_PATCH: 1,
  CAN_HOIST: 2,
  CAN_STRINGIFY: 3
}

const ElementTypes = {
  ELEMENT: 0,
  COMPONENT: 1,
  SLOT: 2,
  TEMPLATE: 3
}

const Namespaces = {
  HTML: 0
}

const NodeTypes = {
  ROOT: 0,
  ELEMENT: 1,
  TEXT: 2,
  COMMENT: 3,
  SIMPLE_EXPRESSION: 4,
  INTERPOLATION: 5,
  ATTRIBUTE: 6,
  DIRECTIVE: 7,
  // containers
  COMPOUND_EXPRESSION: 8,
  IF: 9,
  IF_BRANCH: 10,
  FOR: 11,
  TEXT_CALL: 12,
  // codegen
  VNODE_CALL: 13,
  JS_CALL_EXPRESSION: 14,
  JS_OBJECT_EXPRESSION: 15,
  JS_PROPERTY: 16,
  JS_ARRAY_EXPRESSION: 17,
  JS_FUNCTION_EXPRESSION: 18,
  JS_CONDITIONAL_EXPRESSION: 19,
  JS_CACHE_EXPRESSION: 20,

  // ssr codegen
  JS_BLOCK_STATEMENT: 21,
  JS_TEMPLATE_LITERAL: 22,
  JS_IF_STATEMENT: 23,
  JS_ASSIGNMENT_EXPRESSION: 24,
  JS_SEQUENCE_EXPRESSION: 25,
  JS_RETURN_STATEMENT: 26
}

const __DEV__ = true
const defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => Namespaces.HTML,
  getTextMode: () => TextModes.DATA,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: __DEV__
}

const TagType = {
  Start: 0,
  End: 1
}

const TextModes = {
  DATA: 0,
  RCDATA: 1,
  RAWTEXT: 2,
  CDATA: 3,
  ATTRIBUTE_VALUE: 4
}

let debugOn = true
const log = (fn, message) => {
  if (debugOn) {
    if (message === undefined) {
      console.log(fn)
    } else {
      console.log(`[${fn}] ${message}`)
    }
  }
}
const logOn = () => (debugOn = true)
const logOff = () => (debugOn = false)
const logEnd = (hint = "END") => {
  const m = `--------- ${hint} ---------`
  if (debugOn)
    pushLog(m, 'title')
  return m
}
const logBr = () => console.log("\n")
let debugTraverseOn = true
const logTraverseOn = () => (debugTraverseOn=true)
const logTraverseOff = () => (debugTraverseOn=false)
const logg = ( hint, ...msg ) => {
  if (!debugTraverseOn && hint === 'traverseNode') return
  const m = logEnd(hint)
  msg.forEach((m) => pushLog(m))
}
function pushLog(m, type = 'normal') {
  ;( logs[currentLogKey] || (logs[currentLogKey] = [])).push({ value: m, type })
  log(m)
}
function clearLog() {
  logs = {}
}

<<glovalFns>>

<<runtimeHelpers>>

<<patchFlags>>

<<injectProp>>

<<BindingTypes>>

<<babelUtils>>

<<member-expression>>

<<hasScopeRef>>

<<SlotFlags>>

<<testUtils>>

#+end_src
#+end_details

#+html: <br>
#+begin_details Global Functions :title-color green

#+name: glovalFns
#+begin_src js -n -r
const extend = Object.assign

function defaultOnError(error) {
  throw error
}

function defaultOnWarn(msg) {
  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)
}

function makeMap(str, expectsLowerCase) {
  const map = Object.create(null)
  const list = str.split(',')
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true
  }
  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]
}

const hasOwnProperty = Object.prototype.hasOwnProperty
const hasOwn = (val, key) => hasOwnProperty.call(val, key)

const isArray = Array.isArray
const isMap = (val) => toTypeString(val) === '[object Map]'
const isSet = (val) => toTypeString(val) === '[object Set]'

const isDate = (val) => val instanceof Date
const isFunction = (val) => typeof val === 'function'
const isString = (val) => typeof val === 'string'
const isSymbol = (val) => typeof val === 'symbol'
const isObject = (val) => val !== null && typeof val === 'object'
const onRE = /^on[^a-z]/
const isOn = (key) => onRE.test(key)

const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch)
}

const objectToString = Object.prototype.toString
const toTypeString = (value) => objectToString.call(value)

const toRawType = (value) => {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1)
}

function isText(node) { (ref:isText)
  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT
}

const isPlainObject = (val) => toTypeString(val) === '[object Object]'
const isIntegerKey = (key) =>
  isString(key) &&
  key !== 'NaN' &&
  key[0] !== '-' &&
  '' + parseInt(key, 10) === key

const isReservedProp = /*#__PURE__*/ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted'
)

const GLOBALS_WHITE_LISTED =
  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'

const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)

const nonIdentifierRE = /^\d|[^\$\w]/
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name)

const isBuiltInDirective = /*#__PURE__*/ makeMap(
  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'
)

function getCursor(context) {
  const { column, line, offset } = context
  return { column, line, offset }
}

function getSelection(context, start, end) {
  end = end || getCursor(context)
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  }
}

function last(xs) {
  return xs[xs.length - 1]
}

function startsWith(source, searchString) {
  return source.startsWith(searchString)
}

function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0
  let lastNewLinePos = -1
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10 /* newline char code */) {
      linesCount++
      lastNewLinePos = i
    }
  }

  pos.offset += numberOfCharacters
  pos.line += linesCount
  pos.column =
    lastNewLinePos === -1
      ? pos.column + numberOfCharacters
      : numberOfCharacters - lastNewLinePos

  return pos
}

function advancePositionWithClone(
  pos,
  source,
  numberOfCharacters = source.length
) {
  return advancePositionWithMutation(
    extend({}, pos),
    source,
    numberOfCharacters
  )
}


function advanceBy(context, numberOfCharacters) {
  const { source } = context
  advancePositionWithMutation(context, source, numberOfCharacters)
  context.source = source.slice(numberOfCharacters)
}

function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source)
  if (match) {
    advanceBy(context, match[0].length)
  }
}

function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(
    start,
    context.originalSource.slice(start.offset, numberOfCharacters),
    numberOfCharacters
  )
}

function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset
    loc.column += offset
  }
  // ignore...
}

function isEnd(context, mode, ancestors) {
  const s = context.source

  switch (mode) {
    case TextModes.DATA:
      if (startsWith(s, '</')) {
        // TODO: probably bad performance
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true
          }
        }
      }
      break

    case TextModes.RCDATA:
    case TextModes.RAWTEXT: {
      const parent = last(ancestors)
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true
      }
      break
    }

    case TextModes.CDATA:
      if (startsWith(s, ']]>')) {
        return true
      }
      break
  }

  return !s
}

function startsWithEndTagOpen(source, tag) {
  return (
    startsWith(source, '</') &&
    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
    /[\t\r\n\f />]/.test(source[2 + tag.length] || '>')
  )
}

const cacheStringFunction = (fn) => {
  const cache = Object.create(null)
  return ((str) => {
    const hit = cache[str]
    return hit || (cache[str] = fn(str))
  })
}

const camelizeRE = /-(\w)/g
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))
})

const hyphenateRE = /\B([A-Z])/g
const hyphenate = cacheStringFunction((str) =>
  str.replace(hyphenateRE, '-$1').toLowerCase()
)
const capitalize = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
)
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``)

const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected)

function isCoreComponent(tag) {
  if (isBuiltInType(tag, 'Teleport')) {
    return TELEPORT
  } else if (isBuiltInType(tag, 'Suspense')) {
    return SUSPENSE
  } else if (isBuiltInType(tag, 'KeepAlive')) {
    return KEEP_ALIVE
  } else if (isBuiltInType(tag, 'BaseTransition')) {
    return BASE_TRANSITION
  }
}

const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(
  `if,else,else-if,for,slot`
)

<<isComponent>>
<<pushNode>>

function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE
}

function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK
}

function isSingleElementRoot(root, child) {
  const { children } = root
  return (
    children.length === 1 &&
    child.type === NodeTypes.ELEMENT &&
    !isSlotOutlet(child)
  )
}

function isSlotOutlet(node) {
  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT
}

function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (
      p.type === NodeTypes.DIRECTIVE &&
      (allowEmpty || p.exp) &&
      (isString(name) ? p.name === name : name.test(p.name))
    ) {
      return p
    }
  }
}

function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      if (dynamicOnly) continue
      if (p.name === name && (p.value || allowEmpty)) {
        return p
      }
    } else if (
      p.name === 'bind' &&
      (p.exp || allowEmpty) &&
      isStaticArgOf(p.arg, name)
    ) {
      return p
    }
  }
}

const isStaticExp = (p) => p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic

function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name)
}

function isVSlot(p) {
  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'
}

function getMemoedVNodeCall(node) {
  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {
    return node.arguments[1].returns
  } else {
    return node
  }
}

function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length)
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  }

  if (length != null) {
    newLoc.end = advancePositionWithClone(
      loc.start,
      loc.source,
      offset + length
    )
  }

  return newLoc
}

function toValidAssetId(name, type) {
  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()
  })}`
}

function isTemplateNode(node) {
  return (
    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE
  )
}
#+end_src

检查是不是组件类型：

#+name: isComponent
#+begin_src js -n -r
function isComponent(tag, props, context) {
  const options = context.options
  if (options.isCustomElement(tag)) {
    return false
  }
  if (
    tag === 'component' ||
    /^[A-Z]/.test(tag) ||
    isCoreComponent(tag) ||
    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
    (options.isNativeTag && !options.isNativeTag(tag))
  ) {
    return true
  }
  // at this point the tag should be a native tag, but check for potential "is"
  // casting
  for (let i = 0; i < props.length; i++) {
    const p = props[i]
    if (p.type === NodeTypes.ATTRIBUTE) {
      if (p.name === 'is' && p.value) {
        if (p.value.content.startsWith('vue:')) {
          return true
        }
      }
    } else {
      // directive
      // v-is (TODO Deprecate)
      if (p.name === 'is') {
        return true
      }
    }
  }
}
#+end_src

合并相邻的两个文本节点:
#+name: pushNode
#+begin_src js -n -r
function pushNode(nodes, node) {
  if (node.type === NodeTypes.TEXT) {
    const prev = last(nodes)
    // Merge if both this and the previous node are text and those are
    // consecutive. This happens for cases like "a < b".
    if (
      prev &&
      prev.type === NodeTypes.TEXT &&
      prev.loc.end.offset === node.loc.start.offset
    ) {
      prev.content += node.content
      prev.loc.end = node.loc.end
      prev.loc.source += node.loc.source
      return
    }
  }

  nodes.push(node)
}
#+end_src

#+end_details

#+html: <br>
#+begin_details runtimeHelpers used in transform phase :title-color green
#+name: runtimeHelpers
#+begin_src js -n -r
const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)
const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)
const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)
const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)
const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)
const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)
const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)
const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)
const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)
const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)
const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)
const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)
const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)
const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)
const RESOLVE_DYNAMIC_COMPONENT = Symbol(
  __DEV__ ? `resolveDynamicComponent` : ``
)
const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)
const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)
const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)
const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)
const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)
const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)
const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)
const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)
const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)
const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)
const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)
const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)
const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)
const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)
const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)
const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)
const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)
const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)
const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)
const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)
const UNREF = Symbol(__DEV__ ? `unref` : ``)
const IS_REF = Symbol(__DEV__ ? `isRef` : ``)
const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)
const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)

// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
}

function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach(s => {
    helperNameMap[s] = helpers[s]
  })
}

#+end_src
#+end_details

#+html: <br>
#+begin_details patchFlags :title-color green
#+name: patchFlags
#+begin_src js -n -r
/**
 ,* Patch flags are optimization hints generated by the compiler.
 ,* when a block with dynamicChildren is encountered during diff, the algorithm
 ,* enters "optimized mode". In this mode, we know that the vdom is produced by
 ,* a render function generated by the compiler, so the algorithm only needs to
 ,* handle updates explicitly marked by these patch flags.
 ,*
 ,* Patch flags can be combined using the | bitwise operator and can be checked
 ,* using the & operator, e.g.
 ,*
 ,* ```js
 ,* const flag = TEXT | CLASS
 ,* if (flag & TEXT) { ... }
 ,* ```
 ,*
 ,* Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the
 ,* flags are handled during diff.
 ,*/
const PatchFlags = {
  /**
   ,* Indicates an element with dynamic textContent (children fast path)
   ,*/
  TEXT: 1,

  /**
   ,* Indicates an element with dynamic class binding.
   ,*/
  CLASS: 1 << 1,

  /**
   ,* Indicates an element with dynamic style
   ,* The compiler pre-compiles static string styles into static objects
   ,* + detects and hoists inline static objects
   ,* e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted
   ,* as:
   ,* ```js
   ,* const style = { color: 'red' }
   ,* render() { return e('div', { style }) }
   ,* ```
   ,*/
  STYLE: 1 << 2,

  /**
   ,* Indicates an element that has non-class/style dynamic props.
   ,* Can also be on a component that has any dynamic props (includes
   ,* class/style). when this flag is present, the vnode also has a dynamicProps
   ,* array that contains the keys of the props that may change so the runtime
   ,* can diff them faster (without having to worry about removed props)
   ,*/
  PROPS: 1 << 3,

  /**
   ,* Indicates an element with props with dynamic keys. When keys change, a full
   ,* diff is always needed to remove the old key. This flag is mutually
   ,* exclusive with CLASS, STYLE and PROPS.
   ,*/
  FULL_PROPS: 1 << 4,

  /**
   ,* Indicates an element with event listeners (which need to be attached
   ,* during hydration)
   ,*/
  HYDRATE_EVENTS: 1 << 5,

  /**
   ,* Indicates a fragment whose children order doesn't change.
   ,*/
  STABLE_FRAGMENT: 1 << 6,

  /**
   ,* Indicates a fragment with keyed or partially keyed children
   ,*/
  KEYED_FRAGMENT: 1 << 7,

  /**
   ,* Indicates a fragment with unkeyed children.
   ,*/
  UNKEYED_FRAGMENT: 1 << 8,

  /**
   ,* Indicates an element that only needs non-props patching, e.g. ref or
   ,* directives (onVnodeXXX hooks). since every patched vnode checks for refs
   ,* and onVnodeXXX hooks, it simply marks the vnode so that a parent block
   ,* will track it.
   ,*/
  NEED_PATCH: 1 << 9,

  /**
   ,* Indicates a component with dynamic slots (e.g. slot that references a v-for
   ,* iterated value, or dynamic slot names).
   ,* Components with this flag are always force updated.
   ,*/
  DYNAMIC_SLOTS: 1 << 10,

  /**
   ,* Indicates a fragment that was created only because the user has placed
   ,* comments at the root level of a template. This is a dev-only flag since
   ,* comments are stripped in production.
   ,*/
  DEV_ROOT_FRAGMENT: 1 << 11,

  /**
   ,* SPECIAL FLAGS -------------------------------------------------------------
   ,* Special flags are negative integers. They are never matched against using
   ,* bitwise operators (bitwise matching should only happen in branches where
   ,* patchFlag > 0), and are mutually exclusive. When checking for a special
   ,* flag, simply check patchFlag === FLAG.
   ,*/

  /**
   ,* Indicates a hoisted static vnode. This is a hint for hydration to skip
   ,* the entire sub tree since static content never needs to be updated.
   ,*/
  HOISTED: -1,
  /**
   ,* A special flag that indicates that the diffing algorithm should bail out
   ,* of optimized mode. For example, on block fragments created by renderSlot()
   ,* when encountering non-compiler generated slots (i.e. manually written
   ,* render functions, which should always be fully diffed)
   ,* OR manually cloneVNodes
   ,*/
  BAIL: -2
}

/**
 ,* dev only flag -> name mapping
 ,*/
const PatchFlagNames = {
  [PatchFlags.TEXT]: `TEXT`,
  [PatchFlags.CLASS]: `CLASS`,
  [PatchFlags.STYLE]: `STYLE`,
  [PatchFlags.PROPS]: `PROPS`,
  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,
  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,
  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,
  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,
  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,
  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,
  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,
  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,
  [PatchFlags.HOISTED]: `HOISTED`,
  [PatchFlags.BAIL]: `BAIL`
}

function genFlagText(flag, names = PatchFlagNames) {
  if (isArray(flag)) {
    let f = 0
    flag.forEach(ff => {
      f |= ff
    })
    return `${f} /* ${flag.map(f => names[f]).join(', ')} */`
  } else {
    return `${flag} /* ${names[flag]} */`
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details injectProp :title-color green
#+name: injectProp
#+begin_src js -n -r
const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])

function getUnnormalizedProps(props, callPath = []) {
  if (
    props &&
    !isString(props) &&
    props.type === NodeTypes.JS_CALL_EXPRESSION
  ) {
    const callee = props.callee
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      )
    }
  }
  return [props, callPath]
}

function injectProp(node, prop, context) {
  let propsWithInjection
  /**
   ,* 1. mergeProps(...)
   ,* 2. toHandlers(...)
   ,* 3. normalizeProps(...)
   ,* 4. normalizeProps(guardReactiveProps(...))
   ,*
   ,* we need to get the real props before normalization
   ,*/
  let props =
    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]
  let callPath = []
  let parentCall
  if (
    props &&
    !isString(props) &&
    props.type === NodeTypes.JS_CALL_EXPRESSION
  ) {
    const ret = getUnnormalizedProps(props)
    props = ret[0]
    callPath = ret[1]
    parentCall = callPath[callPath.length - 1]
  }

  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop])
  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {
    // merged props... add ours
    // only inject key to object literal if it's the first argument so that
    // if doesn't override user provided keys
    const first = props.arguments[0] | JSChildNode
    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {
      first.properties.unshift(prop)
    } else {
      if (props.callee === TO_HANDLERS) {
        // #2366
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ])
      } else {
        props.arguments.unshift(createObjectExpression([prop]))
      }
    }
    !propsWithInjection && (propsWithInjection = props)
  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {
    let alreadyExists = false
    // check existing key to avoid overriding user provided keys
    if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {
      const propKeyName = prop.key.content
      alreadyExists = props.properties.some(
        p =>
          p.key.type === NodeTypes.SIMPLE_EXPRESSION &&
          p.key.content === propKeyName
      )
    }
    if (!alreadyExists) {
      props.properties.unshift(prop)
    }
    propsWithInjection = props
  } else {
    // single v-bind with expression, return a merged replacement
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ])
    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
    // the `guardReactiveProps` will no longer be needed
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2]
    }
  }
  if (node.type === NodeTypes.VNODE_CALL) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection
    } else {
      node.props = propsWithInjection
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection
    } else {
      node.arguments[2] = propsWithInjection
    }
  }
}
#+end_src
#+end_details

#+html: <br>
#+begin_details BindingTypes :title-color green
#+name: BindingTypes
#+begin_src js -n -r
const BindingTypes = {
  /**
   * returned from data()
   */
  DATA: 'data',
  /**
   * declared as a prop
   */
  PROPS: 'props',
  /**
   * a local alias of a `<script setup>` destructured prop.
   * the original is stored in __propsAliases of the bindingMetadata object.
   */
  PROPS_ALIASED: 'props-aliased',
  /**
   * a let binding (may or may not be a ref)
   */
  SETUP_LET: 'setup-let',
  /**
   * a const binding that can never be a ref.
   * these bindings don't need `unref()` calls when processed in inlined
   * template expressions.
   */
  SETUP_CONST: 'setup-const',
  /**
   * a const binding that may be a ref.
   */
  SETUP_MAYBE_REF: 'setup-maybe-ref',
  /**
   * bindings that are guaranteed to be refs
   */
  SETUP_REF: 'setup-ref',
  /**
   * declared by other options, e.g. computed, inject
   */
  OPTIONS: 'options'
}
#+end_src
#+end_details

#+html: <br>
#+begin_details babelUtils :title-color green
#+name: babelUtils
#+begin_src js -n -r
<<estree-walker>>

function isInDestructureAssignment(
  parent,
  parentStack
) {
  if (
    parent &&
    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')
  ) {
    let i = parentStack.length
    while (i--) {
      const p = parentStack[i]
      if (p.type === 'AssignmentExpression') {
        return true
      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
        break
      }
    }
  }
  return false
}


function walkIdentifiers(
  root,
  onIdentifier,
  includeAll = false,
  parentStack = [],
  knownIds = Object.create(null)
) {
  if (__BROWSER__) {
    return
  }

  const rootExp =
    root.type === 'Program' &&
    root.body[0].type === 'ExpressionStatement' &&
    root.body[0].expression

  walk(root, {
    enter(node, parent) {
      parent && parentStack.push(parent)
      if (
        parent &&
        parent.type.startsWith('TS') &&
        parent.type !== 'TSAsExpression' &&
        parent.type !== 'TSNonNullExpression' &&
        parent.type !== 'TSTypeAssertion'
      ) {
        return this.skip()
      }
      if (node.type === 'Identifier') {
        const isLocal = !!knownIds[node.name]
        const isRefed = isReferencedIdentifier(node, parent, parentStack)
        if (includeAll || (isRefed && !isLocal)) {
          onIdentifier(node, parent, parentStack, isRefed, isLocal)
        }
      } else if (
        node.type === 'ObjectProperty' &&
        parent.type === 'ObjectPattern'
      ) {
        // mark property in destructure pattern
        node.inPattern = true
      } else if (isFunctionType(node)) {
        // walk function expressions and add its arguments to known identifiers
        // so that we don't prefix them
        walkFunctionParams(node, id => markScopeIdentifier(node, id, knownIds))
      } else if (node.type === 'BlockStatement') {
        // #3445 record block-level local variables
        walkBlockDeclarations(node, id =>
          markScopeIdentifier(node, id, knownIds)
        )
      }
    },
    leave(node, parent) {
      parent && parentStack.pop()
      if (node !== rootExp && node.scopeIds) {
        for (const id of node.scopeIds) {
          knownIds[id]--
          if (knownIds[id] === 0) {
            delete knownIds[id]
          }
        }
      }
    }
  })
}

function isReferencedIdentifier(
  id,
  parent,
  parentStack
) {
  if (__BROWSER__) {
    return false
  }

  if (!parent) {
    return true
  }

  // is a special keyword but parsed as identifier
  if (id.name === 'arguments') {
    return false
  }

  if (isReferenced(id, parent)) {
    return true
  }

  // babel's isReferenced check returns false for ids being assigned to, so we
  // need to cover those cases here
  switch (parent.type) {
    case 'AssignmentExpression':
    case 'AssignmentPattern':
      return true
    case 'ObjectPattern':
    case 'ArrayPattern':
      return isInDestructureAssignment(parent, parentStack)
  }

  return false
}

function isInDestructureAssignment(
  parent,
  parentStack
) {
  if (
    parent &&
    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')
  ) {
    let i = parentStack.length
    while (i--) {
      const p = parentStack[i]
      if (p.type === 'AssignmentExpression') {
        return true
      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {
        break
      }
    }
  }
  return false
}

function walkFunctionParams(
  node,
  onIdent
) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id)
    }
  }
}

function walkBlockDeclarations(
  block,
  onIdent
) {
  for (const stmt of block.body) {
    if (stmt.type === 'VariableDeclaration') {
      if (stmt.declare) continue
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id)
        }
      }
    } else if (
      stmt.type === 'FunctionDeclaration' ||
      stmt.type === 'ClassDeclaration'
    ) {
      if (stmt.declare || !stmt.id) continue
      onIdent(stmt.id)
    }
  }
}

function extractIdentifiers(
  param,
  nodes = []
) {
  switch (param.type) {
    case 'Identifier':
      nodes.push(param)
      break

    case 'MemberExpression':
      let object = param
      while (object.type === 'MemberExpression') {
        object = object.object
      }
      nodes.push(object)
      break

    case 'ObjectPattern':
      for (const prop of param.properties) {
        if (prop.type === 'RestElement') {
          extractIdentifiers(prop.argument, nodes)
        } else {
          extractIdentifiers(prop.value, nodes)
        }
      }
      break

    case 'ArrayPattern':
      param.elements.forEach(element => {
        if (element) extractIdentifiers(element, nodes)
      })
      break

    case 'RestElement':
      extractIdentifiers(param.argument, nodes)
      break

    case 'AssignmentPattern':
      extractIdentifiers(param.left, nodes)
      break
  }

  return nodes
}

function markScopeIdentifier(
  node,
  child,
  knownIds
) {
  const { name } = child
  if (node.scopeIds && node.scopeIds.has(name)) {
    return
  }
  if (name in knownIds) {
    knownIds[name]++
  } else {
    knownIds[name] = 1
  }
  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)
}

const isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)
}

const isStaticProperty = (node) =>
  node &&
  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
  !node.computed

const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node

/**
 ,* Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts
 ,* To avoid runtime dependency on @babel/types (which includes process references)
 ,* This file should not change very often in babel but we may need to keep it
 ,* up-to-date from time to time.
 ,*
 ,* https://github.com/babel/babel/blob/main/LICENSE
 ,*
 ,*/
function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    // yes: PARENT[NODE]
    // yes: NODE.child
    // no: parent.NODE
    case 'MemberExpression':
    case 'OptionalMemberExpression':
      if (parent.property === node) {
        return !!parent.computed
      }
      return parent.object === node

    case 'JSXMemberExpression':
      return parent.object === node
    // no: let NODE = init;
    // yes: let id = NODE;
    case 'VariableDeclarator':
      return parent.init === node

    // yes: () => NODE
    // no: (NODE) => {}
    case 'ArrowFunctionExpression':
      return parent.body === node

    // no: class { #NODE; }
    // no: class { get #NODE() {} }
    // no: class { #NODE() {} }
    // no: class { fn() { return this.#NODE; } }
    case 'PrivateName':
      return false

    // no: class { NODE() {} }
    // yes: class { [NODE]() {} }
    // no: class { foo(NODE) {} }
    case 'ClassMethod':
    case 'ClassPrivateMethod':
    case 'ObjectMethod':
      if (parent.key === node) {
        return !!parent.computed
      }
      return false

    // yes: { [NODE]: "" }
    // no: { NODE: "" }
    // depends: { NODE }
    // depends: { key: NODE }
    case 'ObjectProperty':
      if (parent.key === node) {
        return !!parent.computed
      }
      // parent.value === node
      return !grandparent || grandparent.type !== 'ObjectPattern'
    // no: class { NODE = value; }
    // yes: class { [NODE] = value; }
    // yes: class { key = NODE; }
    case 'ClassProperty':
      if (parent.key === node) {
        return !!parent.computed
      }
      return true
    case 'ClassPrivateProperty':
      return parent.key !== node

    // no: class NODE {}
    // yes: class Foo extends NODE {}
    case 'ClassDeclaration':
    case 'ClassExpression':
      return parent.superClass === node

    // yes: left = NODE;
    // no: NODE = right;
    case 'AssignmentExpression':
      return parent.right === node

    // no: [NODE = foo] = [];
    // yes: [foo = NODE] = [];
    case 'AssignmentPattern':
      return parent.right === node

    // no: NODE: for (;;) {}
    case 'LabeledStatement':
      return false

    // no: try {} catch (NODE) {}
    case 'CatchClause':
      return false

    // no: function foo(...NODE) {}
    case 'RestElement':
      return false

    case 'BreakStatement':
    case 'ContinueStatement':
      return false

    // no: function NODE() {}
    // no: function foo(NODE) {}
    case 'FunctionDeclaration':
    case 'FunctionExpression':
      return false

    // no: export NODE from "foo";
    // no: export * as NODE from "foo";
    case 'ExportNamespaceSpecifier':
    case 'ExportDefaultSpecifier':
      return false

    // no: export { foo as NODE };
    // yes: export { NODE as foo };
    // no: export { NODE as foo } from "foo";
    case 'ExportSpecifier':
      // @ts-expect-error
      if (grandparent?.source) {
        return false
      }
      return parent.local === node

    // no: import NODE from "foo";
    // no: import * as NODE from "foo";
    // no: import { NODE as foo } from "foo";
    // no: import { foo as NODE } from "foo";
    // no: import NODE from "bar";
    case 'ImportDefaultSpecifier':
    case 'ImportNamespaceSpecifier':
    case 'ImportSpecifier':
      return false

    // no: import "foo" assert { NODE: "json" }
    case 'ImportAttribute':
      return false

    // no: <div NODE="foo" />
    case 'JSXAttribute':
      return false

    // no: [NODE] = [];
    // no: ({ NODE }) = [];
    case 'ObjectPattern':
    case 'ArrayPattern':
      return false

    // no: new.NODE
    // no: NODE.target
    case 'MetaProperty':
      return false

    // yes: type X = { someProperty: NODE }
    // no: type X = { NODE: OtherType }
    case 'ObjectTypeProperty':
      return parent.key !== node

    // yes: enum X { Foo = NODE }
    // no: enum X { NODE }
    case 'TSEnumMember':
      return parent.id !== node

    // yes: { [NODE]: value }
    // no: { NODE: value }
    case 'TSPropertySignature':
      if (parent.key === node) {
        return !!parent.computed
      }

      return true
  }

  return true
}

#+end_src
#+end_details

** babel utils

递归遍历 AST 树。

#+name: estree-walker
#+begin_src js -n -r
class WalkerBase {
  constructor() {
    /** @type {boolean} */
    this.should_skip = false

    /** @type {boolean} */
    this.should_remove = false

    /** @type {BaseNode | null} */
    this.replacement = null

    /** @type {WalkerContext} */
    this.context = {
      skip: () => (this.should_skip = true),
      remove: () => (this.should_remove = true),
      replace: (node) => (this.replacement = node)
    }
  }

  replace(parent, prop, index, node) {
    if (parent) {
      if (index !== null) {
        parent[prop][index] = node
      } else {
        parent[prop] = node
      }
    }
  }

  remove(parent, prop, index) {
    if (parent) {
      if (index !== null) {
        parent[prop].splice(index, 1)
      } else {
        delete parent[prop]
      }
    }
  }
}

class SyncWalker extends WalkerBase {

  constructor(enter, leave) {
    super()

    /** @type {SyncHandler} */
    this.enter = enter

    /** @type {SyncHandler} */
    this.leave = leave
  }

  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip
        const _should_remove = this.should_remove
        const _replacement = this.replacement
        this.should_skip = false
        this.should_remove = false
        this.replacement = null

        this.enter.call(this.context, node, parent, prop, index)

        if (this.replacement) {
          node = this.replacement
          this.replace(parent, prop, index, node)
        }

        if (this.should_remove) {
          this.remove(parent, prop, index)
        }

        const skipped = this.should_skip
        const removed = this.should_remove

        this.should_skip = _should_skip
        this.should_remove = _should_remove
        this.replacement = _replacement

        if (skipped) return node
        if (removed) return null
      }

      for (const key in node) {
        const value = node[key]

        if (typeof value !== 'object') {
          continue
        } else if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i += 1) {
            if (value[i] !== null && typeof value[i].type === 'string') {
              if (!this.visit(value[i], node, key, i)) {
                // removed
                i--
              }
            }
          }
        } else if (value !== null && typeof value.type === 'string') {
          this.visit(value, node, key, null)
        }
      }

      if (this.leave) {
        const _replacement = this.replacement
        const _should_remove = this.should_remove
        this.replacement = null
        this.should_remove = false

        this.leave.call(this.context, node, parent, prop, index)

        if (this.replacement) {
          node = this.replacement
          this.replace(parent, prop, index, node)
        }

        if (this.should_remove) {
          this.remove(parent, prop, index)
        }

        const removed = this.should_remove

        this.replacement = _replacement
        this.should_remove = _should_remove

        if (removed) return null
      }
    }

    return node
  }
}

class AsyncWalker extends WalkerBase {

  constructor(enter, leave) {
    super()

    /** @type {AsyncHandler} */
    this.enter = enter

    /** @type {AsyncHandler} */
    this.leave = leave
  }

  async visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip
        const _should_remove = this.should_remove
        const _replacement = this.replacement
        this.should_skip = false
        this.should_remove = false
        this.replacement = null

        await this.enter.call(this.context, node, parent, prop, index)

        if (this.replacement) {
          node = this.replacement
          this.replace(parent, prop, index, node)
        }

        if (this.should_remove) {
          this.remove(parent, prop, index)
        }

        const skipped = this.should_skip
        const removed = this.should_remove

        this.should_skip = _should_skip
        this.should_remove = _should_remove
        this.replacement = _replacement

        if (skipped) return node
        if (removed) return null
      }

      for (const key in node) {
        const value = node[key]

        if (typeof value !== 'object') {
          continue
        } else if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i += 1) {
            if (value[i] !== null && typeof value[i].type === 'string') {
              if (!(await this.visit(value[i], node, key, i))) {
                // removed
                i--
              }
            }
          }
        } else if (value !== null && typeof value.type === 'string') {
          await this.visit(value, node, key, null)
        }
      }

      if (this.leave) {
        const _replacement = this.replacement
        const _should_remove = this.should_remove
        this.replacement = null
        this.should_remove = false

        await this.leave.call(this.context, node, parent, prop, index)

        if (this.replacement) {
          node = this.replacement
          this.replace(parent, prop, index, node)
        }

        if (this.should_remove) {
          this.remove(parent, prop, index)
        }

        const removed = this.should_remove

        this.replacement = _replacement
        this.should_remove = _should_remove

        if (removed) return null
      }
    }

    return node
  }
}

function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave)
  return instance.visit(ast, null)
}

async function asyncWalk(ast, { enter, leave }) {
  const instance = new AsyncWalker(enter, leave)
  return await instance.visit(ast, null)
}

#+end_src
** member expression

#+name: member-expression
#+begin_src js -n -r
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g

const MemberExpLexState = {
  inMemberExp: 0,
  inBrackets: 1,
  inParens: 2,
  inString: 3
}

const isMemberExpressionBrowser = path => {
  // remove whitespaces around . or [ first
  path = path.trim().replace(whitespaceRE, s => s.trim())

  let state = MemberExpLexState.inMemberExp
  let stateStack = []
  let currentOpenBracketCount = 0
  let currentOpenParensCount = 0
  let currentStringType = null

  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i)
    switch (state) {
      case MemberExpLexState.inMemberExp:
        if (char === '[') {
          stateStack.push(state)
          state = MemberExpLexState.inBrackets
          currentOpenBracketCount++
        } else if (char === '(') {
          stateStack.push(state)
          state = MemberExpLexState.inParens
          currentOpenParensCount++
        } else if (
          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)
        ) {
          return false
        }
        break
      case MemberExpLexState.inBrackets:
        if (char === `'` || char === `"` || char === '`') {
          stateStack.push(state)
          state = MemberExpLexState.inString
          currentStringType = char
        } else if (char === `[`) {
          currentOpenBracketCount++
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop()
          }
        }
        break
      case MemberExpLexState.inParens:
        if (char === `'` || char === `"` || char === '`') {
          stateStack.push(state)
          state = MemberExpLexState.inString
          currentStringType = char
        } else if (char === `(`) {
          currentOpenParensCount++
        } else if (char === `)`) {
          // if the exp ends as a call then it should not be considered valid
          if (i === path.length - 1) {
            return false
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop()
          }
        }
        break
      case MemberExpLexState.inString:
        if (char === currentStringType) {
          state = stateStack.pop()
          currentStringType = null
        }
        break
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount
}

const isMemberExpressionNode = __BROWSER__
  ? NOOP
  : (path, context) => {
      try {
        let ret = babelParser.parseExpression(path, {
          plugins: context.expressionPlugins
        })
        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {
          ret = ret.expression
        }
        return (
          ret.type === 'MemberExpression' ||
          ret.type === 'OptionalMemberExpression' ||
          ret.type === 'Identifier'
        )
      } catch (e) {
        return false
      }
    }

const isMemberExpression = __BROWSER__
  ? isMemberExpressionBrowser
  : isMemberExpressionNode
#+end_src
** scope ref

#+name: hasScopeRef
#+begin_src js -n -r
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i]
        if (
          p.type === NodeTypes.DIRECTIVE &&
          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))
        ) {
          return true
        }
      }
      return node.children.some(c => hasScopeRef(c, ids))
    case NodeTypes.FOR:
      if (hasScopeRef(node.source, ids)) {
        return true
      }
      return node.children.some(c => hasScopeRef(c, ids))
    case NodeTypes.IF:
      return node.branches.some(b => hasScopeRef(b, ids))
    case NodeTypes.IF_BRANCH:
      if (hasScopeRef(node.condition, ids)) {
        return true
      }
      return node.children.some(c => hasScopeRef(c, ids))
    case NodeTypes.SIMPLE_EXPRESSION:
      return (
        !node.isStatic &&
        isSimpleIdentifier(node.content) &&
        !!ids[node.content]
      )
    case NodeTypes.COMPOUND_EXPRESSION:
      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))
    case NodeTypes.INTERPOLATION:
    case NodeTypes.TEXT_CALL:
      return hasScopeRef(node.content, ids)
    case NodeTypes.TEXT:
    case NodeTypes.COMMENT:
      return false
    default:
      if (__DEV__) {
        const exhaustiveCheck = node
        exhaustiveCheck
      }
      return false
  }
}
#+end_src
** SlotFlags

#+name: SlotFlags
#+begin_src js -n -r
const SlotFlags = { (ref:SlotFlags)
  /**
   * Stable slots that only reference slot props or context state. The slot
   * can fully capture its own dependencies so when passed down the parent won't
   * need to force the child to update.
   */
  STABLE: 1,
  /**
   * Slots that reference scope variables (v-for or an outer slot prop), or
   * has conditional structure (v-if, v-for). The parent will need to force
   * the child to update because the slot does not fully capture its dependencies.
   */
  DYNAMIC: 2,
  /**
   * `<slot/>` being forwarded into a child component. Whether the parent needs
   * to update the child is dependent on what kind of slots the parent itself
   * received. This has to be refined at runtime, when the child's vnode
   * is being created (in `normalizeChildren`)
   */
  FORWARDED: 3
}

/**
 * Dev only
 */
const slotFlagsText = {
  [SlotFlags.STABLE]: 'STABLE',
  [SlotFlags.DYNAMIC]: 'DYNAMIC',
  [SlotFlags.FORWARDED]: 'FORWARDED'
}

#+end_src
** test utils

#+name: testUtils
#+begin_src js -n -r
function createElementWithCodegen(
  tag,
  props,
  children,
  patchFlag,
  dynamicProps
) {
  return {
    type: NodeTypes.ELEMENT,
    loc: locStub,
    ns: Namespaces.HTML,
    tag: 'div',
    tagType: ElementTypes.ELEMENT,
    isSelfClosing: false,
    props: [],
    children: [],
    codegenNode: {
      type: NodeTypes.VNODE_CALL,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives: undefined,
      isBlock: false,
      disableTracking: false,
      isComponent: false,
      loc: locStub
    }
  }
}
#+end_src
** debug utils

#+name: debugUtils
#+begin_src js -n -r
let w = {}
let debugEle = null
if (__BROWSER__) {
  w = typeof window !== 'undefined' ? window : {}
}
w.log = (msg, isLine = false) => {
  if (debugEle) {
    const cls = ['debug', isLine ? 'line' : ''].filter(Boolen)
    ele.innerHTML = `${debugEl.innerHTML}<pre class="${cls.join(' ')}"><code>${
      typeof msg === 'object' ? syntaxHighlight(msg) : msg
    }</code></pre>`
    return ele.innerHTML
  }
}

function syntaxHighlight(json) {
  if (typeof json != 'string') {
    json = JSON.stringify(json, undefined, 2)
  }
  json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
  return json.replace(
    /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
    function (match) {
      var cls = 'number'
      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          cls = 'key'
        } else {
          cls = 'string'
        }
      } else if (/true|false/.test(match)) {
        cls = 'boolean'
      } else if (/null/.test(match)) {
        cls = 'null'
      }
      return '<span class="' + cls + '">' + match + '</span>'
    }
  )
}
#+end_src
* ast parser
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: cc-ast-parser
:END:

#+begin_export html
<a href="../assets/img/vue3/compiler-core/compiler-core-parser.svg"
   data-fancybox="gallery"
   data-caption="Preview"
><img src="../assets/img/vue3/compiler-core/compiler-core-parser.svg"/></a>
#+end_export

解析器包含以下函数：

#+name: parse-functions-table
| Function              | Description                               |
|-----------------------+-------------------------------------------|
| [[baseParse][baseParse()]]           | entry function                            |
| [[parseChildren][parseChildren()]]       | parse children nodes                      |
| [[parseCDATA][parseCDATA()]]          | parse ~CDATA~ type content                  |
| [[parseComment][parseComment()]]        | parse comment node                        |
| [[parseBogusComment][parseBogusComment()]]   | parse ~<!...>~ or ~<?...>~  comment           |
| [[parseElement][parseElement()]]        | parse normal HTML element/component nodes |
| [[parseTag][parseTag()]]            | parse normal HTML tag(~<div id=a>~) nodes   |
| [[parseAttributes][parseAttributes()]]     | parse tag attribute(eg. ~<div foo="100"/>~) |
| [[parseAttribute][parseAttribute()]]      | parse tag attribute.                      |
| [[parseAttributeValue][parseAttributeValue()]] | parse tag attribute value                 |
| [[parseText][parseText()]]           | parse pure text node                      |
| [[parseTextData][parseTextData()]]       | parse text node value                     |

** baseParse()

#+name: baseParse
#+begin_src js -n -r
<<createParserContext>>
<<createRoot>>
<<parseChildren>>
<<parseElement>>
<<parseTag>>
<<parseText>>
<<parseTextData>>
<<parseInterpolation>>
<<parseAttributes>>
<<parseAttribute>>
<<parseAttributeValue>>

function baseParse(content, options = {}) {
  const context = createParserContext(content, options)
  const start = getCursor(context)
  return createRoot(
    parseChildren(context, TextModes.DATA, []),
    getSelection(context, start)
  )
}
#+end_src

- 一个 app 下只会有一个 parser context 上下文
- 一个 app 只有一个 root 节点，由 [[createRoot][createRoot()]] 创建
- parser 从 [[parseChildren][parseChildren()]]  解析第一个子节点开始

** createParserContext()

创建 parser 上下文结构对象：

#+name: createParserContext
#+begin_src js -n -r
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions)

  let key
  for (key in rawOptions) {
    // @ts-ignore
    options[key] =
      rawOptions[key] === undefined
        ? defaultParserOptions[key]
        : rawOptions[key]
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content, (ref:context-originalSource)
    source: content, (ref:context-source)
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  }
}
#+end_src

column, line, offset 表示解析光标停留的位置，这个可以用来调试过程中遇到错误时能
精准给出发生异常的行和列号。

~inPre~ 和 ~inVPre~ 是表示模板是不是在 ~<pre/>~ 标签或者 ~<div v-pre>~ 指令中。

[[(context-originalSource)][originalSource]]: 解析之前的原始模板，如： ~<div id="test"/>~

[[(context-source)][source]]: 解析当下的模板，解析一点会丢弃一点，如： ~id="test"/>~ 这个是
[[(context-originalSource)][originalSource]] 解析出开始标签名 ~div~ 之后剩下的(一个一个字符的解构)。

** parseChildren()

这个是 parser 阶段的解析入口函数， root -> children <-> children 递归调用解析
AST 。

通过节点或标签的类型决定调用哪些 [[parse-functions-table][parse 函数]] 去解析它们。

red:TIP:这里只保留了正常使用情况下的代码异常处理和边界情况都省略掉了

#+name: parseChildren
#+begin_src js -n -r
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors)
  const ns = parent ? parent.ns : Namespaces.HTML
  const nodes = [] // -> ancestors

  // 1. while -> isEnd ? 游标不断往前走直接所以 source 都解析完成
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source
    let node = undefined

    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        // '{{' 插值开始
        node = parseInterpolation(context, mode)
      } else if (mode === TextModes.DATA && s[0] === '<') {
        if (s[1] === '/') {
          // 结束标签
          if (/[a-z]/i.test(s[2])) {
            // 异常结束，如：`<div>some text<a`
            emitError(context, 'X_INVALID_END_TAG')
            parseTag(context, TagType.End, parent)
            continue
          }
        } else if (/[a-z]/i.test(s[1])) {
          // 正常的开始标签
          node = parseElement(context, ancestors)
          // 2.x <template> 无指令兼容，这里就不实现了，重点关注 3.x 的代码
        }
      }
    }
    // 以上都不是，说明应该是纯文本节点
    if (!node) {
      node = parseText(context, mode)
    }

    // 用 pushNode 在其中合并相邻的文本节点
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i])
      }
    } else {
      pushNode(nodes, node)
    }
  }

  // 2. 合并相邻文本节点，空格处理，会将多个空格合并成一个空格
  let removedWhitespace = false
  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {
    removedWhitespace = _removeWhitespace(nodes, context)
  }

  // 3. 最后返回解析后的节点树
  return removedWhitespace ? nodes.filter(Boolean) : nodes
}

function _removeWhitespace(nodes, context) {
  let removedWhitespace = false
  // 可以通过选项来指定是不是保留空格，否则多余的会合并成一个
  const shouldCondense = context.options.whitespace !== 'preserve'
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i]
    if (!context.inPre && node.type === NodeTypes.TEXT) {
      if (!/[^\t\r\n\f]/.test(node.content)) {
        const prev = nodes[i - 1]
        const next = nodes[i + 1]

        if (
          !prev ||
            !next ||
            (shouldCondense && (
              prev.type === NodeTypes.COMMENT || next.type === NodeTypes.COMMENT || (
                prev.type === NodeTypes.ELEMENT && next.type === NodeTypes.ELEMENT && /[\r\n]/.test(node.content)
              )
            ))
        ) {
          removedWhitespace = true
          nodes[i] = null
        } else {
          // 合并成一个
          node.content = ' '
        }
      } else if (shouldCondense) {
        // 保留空格
        node.content = node.content.replace(/[\t\r\n\f]+/g, ' ')
      }
    } else if (node.type === NodeTypes.COMMENT && !context.options.comments) {
      // 可以通过配置删除注释节点
      removedWhitespace = true
      nodes[i] = null
    }
  }

  if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
    // 删除 <pre> 中的第一行的空行
    const first = nodes[0]
    if (first && first.type === NodeTypes.TEXT) {
      first.content = first.content.replace(/^\r?\n/, '')
    }
  }

  return removedWhitespace
}
#+end_src
** parseText()

文本解析函数。

#+name: parseText
#+begin_src js -n -r
function parseText(context, mode) {
  const endTokens = mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]

  let endIndex = context.source.length
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1)
    if (index !== -1 && endIndex > index) {
      endIndex = index
    }
  }

  const start = getCursor(context)
  const content = parseTextData(context, endIndex, mode)

  return {
    type: NodeTypes.TEXT,
    content,
    loc: getSelection(context, start)
  }
}
#+end_src

red:Testing

#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('some text')
const text = ast.children[0]
logEnd('ROOT AST')
log(ast)
logEnd('TEXT AST')
log(text)
#+end_src

#+RESULTS:
#+begin_example
--------- ROOT AST ---------
{
  type: 0,
  children: [ { type: 2, content: 'some text', loc: [Object] } ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'some text'
  }
}
--------- TEXT AST ---------
{
  type: 2,
  content: 'some text',
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 10, line: 1, offset: 9 },
    source: 'some text'
  }
}
undefined
#+end_example

** parseTextData()

根据 [[parseText][parseText()]] 中解析出来的文本长度取出文本内容，这里会将 [[(html-entities)][HTML entities]] 进行转换。

#+name: parseTextData
#+begin_src js -n -r
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length)
  advanceBy(context, length)

  // 不含HTML entities
  if (mode === TextModes.RAWTEXT || mode === TextModes.CDATA || !rawText.includes('&')) {
    return rawText
  } else {
    // 将 &gt; -> `>`, &lt; -> `<`, &amp; -> `&`, &apos; -> `'`, &quot; -> `"`
    return context.options.decodeEntities(rawText, mode === TextModes.ATTRIBUTE_VALUE)
  }
}
#+end_src
** parseInterpolation()

插值解析(~{{...}}~)，根据 ~{{~ 和 ~}}~ 的位置索引找到它们中间的内容，去掉前后多余的空
格之后得到具体的插值内容。

#+name: parseInterpolation
#+begin_src js -n -r
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters

  // 如： source = "{{ a + b }}"
  // closeIndex = indexOf("}}", "{{".length) = 9
  const closeIndex = context.source.indexOf(close, open.length)
  if (closeIndex === -1) {
    emitError(context, 'X_MISSING_INTERPOLATION_END')
    return undefined
  }

  const start = getCursor(context)
  // >> 2 -> " a + b }}"
  advanceBy(context, open.length)

  // { line, column, offset }
  const innerStart = getCursor(context)
  const innerEnd = getCursor(context)
  // 9 - '{{'.length = 7
  const rawContentLength = closeIndex - open.length
  // " a + b }}".slice(0, 7) => " a + b "
  const rawContent = context.source.slice(0, rawContentLength)
  const preTrimContent = parseTextData(context, rawContentLength, mode)
  // " a + b " => "a + b"
  const content = preTrimContent.trim()
  const startOffset = preTrimContent.indexOf(content)
  if (startOffset > 0) {
    // 处理换行问题
    advancePositionWithMutation(innerStart, rawContent, startOffset)
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)
  advancePositionWithMutation(innerEnd, rawContent, endOffset)
  advanceBy(context, close.length)

  return {
    type: NodeTypes.INTERPOLATION,
    content: {
      type: NodeTypes.SIMPLE_EXPRESSION,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: ConstantTypes.NOT_CONSTANT,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  }
}
#+end_src

red:Testing

#+begin_details Testing :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('some {{ foo + bar }} text')
const text1 = ast.children[0]
// 1 -> interpolation
const inter = ast.children[1]
const text2 = ast.children[2]

logg('AST', ast)
logg('Text1', text1)
logg('INTERPOLATION', inter)
logg('Text2', text2)
#+end_src

#+RESULTS:
#+begin_example
--------- AST ---------
{
  type: 0,
  children: [
    { type: 2, content: 'some ', loc: [Object] },
    { type: 5, content: [Object], loc: [Object] },
    { type: 2, content: ' text', loc: [Object] }
  ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 26, line: 1, offset: 25 },
    source: 'some {{ foo + bar }} text'
  }
}
--------- Text1 ---------
{
  type: 2,
  content: 'some ',
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 6, line: 1, offset: 5 },
    source: 'some '
  }
}
--------- INTERPOLATION ---------
{
  type: 5,
  content: {
    type: 4,
    isStatic: false,
    constType: 0,
    content: 'foo + bar',
    loc: { start: [Object], end: [Object], source: 'foo + bar' }
  },
  loc: {
    start: { column: 6, line: 1, offset: 5 },
    end: { column: 21, line: 1, offset: 20 },
    source: '{{ foo + bar }}'
  }
}
--------- Text2 ---------
{
  type: 2,
  content: ' text',
  loc: {
    start: { column: 21, line: 1, offset: 20 },
    end: { column: 26, line: 1, offset: 25 },
    source: ' text'
  }
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details Testing-with-< :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('some {{ a < b && c > d }} text')
const text1 = ast.children[0]
// 1 -> interpolation
const inter = ast.children[1]
const text2 = ast.children[2]

logg('AST', ast)
logg('Text1', text1)
logg('INTERPOLATION', inter)
logg('Text2', text2)
#+end_src

#+RESULTS:
#+begin_example
--------- AST ---------
{
  type: 0,
  children: [
    { type: 2, content: 'some ', loc: [Object] },
    { type: 5, content: [Object], loc: [Object] },
    { type: 2, content: ' text', loc: [Object] }
  ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 31, line: 1, offset: 30 },
    source: 'some {{ a < b && c > d }} text'
  }
}
--------- Text1 ---------
{
  type: 2,
  content: 'some ',
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 6, line: 1, offset: 5 },
    source: 'some '
  }
}
--------- INTERPOLATION ---------
{
  type: 5,
  content: {
    type: 4,
    isStatic: false,
    constType: 0,
    content: 'a < b && c > d',
    loc: { start: [Object], end: [Object], source: 'a < b && c > d' }
  },
  loc: {
    start: { column: 6, line: 1, offset: 5 },
    end: { column: 26, line: 1, offset: 25 },
    source: '{{ a < b && c > d }}'
  }
}
--------- Text2 ---------
{
  type: 2,
  content: ' text',
  loc: {
    start: { column: 26, line: 1, offset: 25 },
    end: { column: 31, line: 1, offset: 30 },
    source: ' text'
  }
}
undefined
#+end_example

#+end_details

** parseElement()

#+name: parseElement
#+begin_src js -n -r
function parseElement(context, ancestors) {
  const parent = last(ancestors)
  // 1. 解析出开始标签
  const element = parseTag(context, TagType.Start, parent)

  // 自闭合的标签： <div/>
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    return element
  }

  // children
  ancestors.push(element)

  const mode = context.options.getTextMode(element, parent)
  // 递归解析子节点
  const children = parseChildren(context, mode, ancestors)
  // 解析完出栈 [root, parent1, parent2, ...] 代表层级
  // <root><parent1><parent2></parent><parent1></root> -> 解析过程中通过
  // ancestors 来维护这个层级关系
  ancestors.pop()

  element.children = children

  // 2. 解析结束标签
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End, parent)
  }

  // 更新解析后节点在源码中的位置信息
  element.loc = getSelection(context, element.loc.start)

  return element
}
#+end_src

#+html: <br>
#+begin_details Testing :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('some <span>text</span>')
const text1 = ast.children[0]
const span = ast.children[1]
const text2 = span.children[0]

logg('AST', ast)
logg('text1', text1)
logg('span', span)
logg('text2', text2)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing self closing :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('<div/>after')
const element = ast.children[0]
const text = ast.children[1]

logg('element', element)
logg('text', text)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing void element by isVoidElement :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>
const ast = baseParse('<img>after', {
  isVoidTag: tag => tag === 'img'
})

const element = ast.children[0]
const text = ast.children[1]

logg('element', element)
logg('text', text)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing slot :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse(`<slot></slot><Comp></Comp>`)

const slot = ast.children[0]
const comp = ast.children[1]

logg('slot', slot)
logg('comp', comp)
#+end_src

#+RESULTS:
#+begin_example
--------- slot ---------
{
  type: 1,
  ns: 0,
  tag: 'slot',
  tagType: 2,
  props: [],
  isSelfClosing: false,
  children: [],
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 14, line: 1, offset: 13 },
    source: '<slot></slot>'
  },
  codegenNode: undefined
}
--------- comp ---------
{
  type: 1,
  ns: 0,
  tag: 'Comp',
  tagType: 1,
  props: [],
  isSelfClosing: false,
  children: [],
  loc: {
    start: { column: 14, line: 1, offset: 13 },
    end: { column: 27, line: 1, offset: 26 },
    source: '<Comp></Comp>'
  },
  codegenNode: undefined
}
undefined
#+end_example

#+end_details
** parseTag()

#+name: parseTag
#+begin_src js -n -r
function parseTag(context, type, parent) {
  // 1. 开始标签
  const start = getCursor(context)
  // 合法标签的正则匹配
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source)
  const tag = match[1]
  const ns = context.options.getNamespace(tag, parent)

  // 游标前进标签名长度的位置，如： <div id="foo"> -> ` id="foo">`
  advanceBy(context, match[0].length)
  // 空格处理
  advanceSpaces(context)

  // parse attributes
  let props = parseAttributes(context, type)

  // TODO v-pre 检测

  // 2. 闭合标签
  let isSelfClosing = false
  if (context.source.length === 0) {
    // 非法情况, ignore
  } else {
    isSelfClosing = startsWith(context.source, '/>')
    advanceBy(context, isSelfClosing ? 2 : 1)
  }

  if (type === TagType.End) {
    return
  }

  // 3. 分析出标签的类型
  let tagType = ElementTypes.ELEMENT
  if (!context.inVPre) {
    if (tag === 'slot') {
      tagType = ElementTypes.SLOT
    } else if (tag === 'template') {
      if (props.some(p => p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name))) {
        tagType = ElementTypes.TEMPLATE
      }
    } else if (isComponent(tag, props, context)) {
      tagType = ElementTypes.COMPONENT
    }
  }

  return {
    type: NodeTypes.ELEMENT,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined // 在 transform 阶段生成的产物
  }
}
#+end_src
** parseAttributes()

#+name: parseAttributes
#+begin_src js -n -r
function parseAttributes(context, type) {
  const props = []
  // 用 set 避免重复属性
  const attributeNames = new Set()
  while (
    context.source.length > 0 &&
      !startsWith(context.source, '>') &&
      !startsWith(context.source, '/>')
  ) {

    // 一些非法检测, ignore

    const attr = parseAttribute(context, attributeNames)

    logg('ATTR', attr)
    // 去掉 class 之间多余的空格，如： `foo   bar  ` -> `foo bar`
    if (attr.type === NodeTypes.ATTRIBUTE &&
       attr.value && attr.name === 'class') { (ref:remove-class-whitespace)
      attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim()
    }

    if (type === TagType.Start) {
      props.push(attr)
    }

    advanceSpaces(context)
  }

  return props
}
#+end_src

#+html: <br>
#+begin_details Testing v-if directive :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse(`<template v-if="ok"></template>`)
const element = ast.children[0]

logg('AST', ast)
logg('element', element)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing template without directives :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse(`<template></template>`)
const element = ast.children[0]

logg('AST', ast)
logg('element', element)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing without value :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse("<div id></div>")
const element = ast.children[0]

logg('AST', ast)
logg('element', element)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing multiple attributes :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('<div id=a class="c" inert style=\'\'>')
const element = ast.children[0]
const props = element.props
logg('AST', ast)
logg('element', element)
logg('props', props)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing class attribute ignore whitespace :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>
const ast = baseParse('<div class=" \n\t c \t\n "></div>')
const element = ast.children[0]

logg('element', element)
logg('props', element.props)
#+end_src

对于 class 值中空格的处理在这 [[parseAttributes][parseAttributes]] 中 [[(remove-class-whitespace)]]。
#+end_details

#+html: <br>
#+begin_details Testing directive with argument :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse('<div v-on:click />')
const element = ast.children[0]
logg('element', element)
logg('props', element.props)
logg('directive', element.props[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing directive with dynamic argument :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse("<div v-on:[event] />")
const element = ast.children[0]
logg('element', element)
logg('directive', element.props[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing directive with argument and modifiers :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse("<div v-on:click.enter.exact />")
const element = ast.children[0]
logg('element', element)
logg('directive', element.props[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing directive with dynamic argument and modifiers and shorthand :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse("<div v-on:[a.b].camel :a=b />")
const element = ast.children[0]
logg('element', element)
logg('directive', element.props[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing complex scenario :title-color red
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>

const ast = baseParse(`
<div
  v-bind:a="b"
  v-bind:[c.d]="e"
  :f="g"
  v-on:[h.i].camel
  v-on:click.camel.exact="j"
  @keyup.enter.prevent="k"
  v-if="l > m"
  .n=o
  :p.sync=q
></div>
<Comp1 #a="{ b }"/>
<Comp2 v-slot:foo.bar="{ a }"/>
`)

const div = ast.children[0]
const comp1 = ast.children[1]
const comp2 = ast.children[2]

logg('div', div)
logg('div-props', div.props)
logg('comp1', comp1)
logg('comp1-slot', comp1.props)
logg('comp2', comp2)
logg('comp2-slot', comp2.props)
#+end_src
#+end_details
*** parseAttribute

#+name: parseAttribute
#+begin_src js -n -r
function parseAttribute(context, nameSet) {
  const start = getCursor(context)
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)
  const name = match[0]

  nameSet.add(name)

  advanceBy(context, name.length)

  let value = undefined

  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context)
    advanceBy(context, 1)
    advanceSpaces(context)
    value = parseAttributeValue(context)
  }

  const loc = getSelection(context, start)

  // v-on(@), v-bind(:), v-if, v-else, v-slot(#) 指令
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name)

    log(`parseAttribute| match=${match}`)
    let isPropShorthand = startsWith(name, '.')
    let dirName =
        match[1] ||
        (isPropShorthand || startsWith(name, ':')
         ? 'bind'
         : startsWith(name, '@')
        ? 'on'
        : 'slot')
    let arg

    if (match[2]) {
      const isSlot = dirName === 'slot'
      const startOffset = name.lastIndexOf(match[2])
      const loc = getSelection(
        context,
        getNewPosition(context, start, startOffset),
        getNewPosition(
          context,
          start,
          startOffset + match[2].length + ((isSlot && match[3]) || '').length
        )
      )

      let content = match[2]
      let isStatic = true

      if (content.startsWith('[')) {
        isStatic = false

        content = content.slice(1, content.length - 1)
      } else if (isSlot){
        content += match[3] || ''
      }

      arg = {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content,
        isStatic,
        constType: isStatic
          ? ConstantTypes.CAN_STRINGIFY
          : ConstantTypes.NOT_CONSTANT,
        loc
      }
    }

    // quoted: `foo="bar"`, not quoted: `foo=bar`
    if (value && value.isQuoted) {
      const valueLoc = value.loc
      valueLoc.start.offset++
      valueLoc.start.column++
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)
      valueLoc.source = valueLoc.source.slice(1, -1)
    }

    // 修饰符 v-bind.number="foo" => '.number' => ['number']
    const modifiers = match[3] ? match[3].slice(1).split('.') : []
    // `<div foo.prop="bar">` 如果不加 `.prop` 这个会被解析到 `$attrs` 中
    // 如果加了 `.prop` 则会被解析到 `$props` 中去
    if (isPropShorthand) {
      modifiers.push('prop')
    }

    return {
      type: NodeTypes.DIRECTIVE,
      name: dirName,
      exp: value && {
        type: NodeTypes.SIMPLE_EXPRESSION,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: ConstantTypes.NOT_CONSTANT,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    }
  }

  return {
    type: NodeTypes.ATTRIBUTE,
    name,
    value: value && {
      type: NodeTypes.TEXT,
      content: value.content,
      loc: value.loc
    },
    loc
  }
}
#+end_src
*** parseAttributeValue

解析属性的值，区分是不是有引号，如果有引号直接使用引号来计算出值，如是没有引号则
使用 ~/^[^\t\t\n\f >]+/~ 正则来匹配。

#+name: parseAttributeValue
#+begin_src js -n -r
function parseAttributeValue(context) {
  const start = getCursor(context)
  let content

  const quote = context.source[0]
  // value 分两种情况，可以用引号包起来也可以不使用引号
  // `<div foo="value">` 或 `<div foo=value>`
  const isQuoted = quote === `"` || quote === `'`
  if (isQuoted) {
    // Quoted value.
    advanceBy(context, 1)

    const endIndex = context.source.indexOf(quote)
    if (endIndex === -1) {
      content = parseTextData(
        context,
        context.source.length,
        TextModes.ATTRIBUTE_VALUE
      )
    } else {
      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)
      advanceBy(context, 1)
    }
  } else {
    // Unquoted
    const match = /^[^\t\r\n\f >]+/.exec(context.source)
    if (!match) {
      return undefined
    }
    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)
  }

  return { content, isQuoted, loc: getSelection(context, start) }
}
#+end_src

* transform
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: cc-transform
:END:

transform 阶段是将 [[cc-ast-parser][ast-parser]] 阶段生成的 AST 树进行加工处理，主要是针对不同的组
件类型和各种指令。

** transform()

#+name: transform
#+begin_src js -n -r
<<createTransformContext>>
<<traverseNode>>
<<traverseChildren>>
<<hoists>>
<<createRootCodegen>>
<<createStructuralDirectiveTransform>>
<<getBaseTransformPreset>>
<<transform-plugins>>
<<ast-creators>>

function transform(root, options) {
  // transform 上下文
  const context = createTransformContext(root, options)

  // 递归遍历整个 ast root 树，最终为每颗子树生成 codegenNode
  traverseNode(root, context)

  // 静态提升处理
  if (options.hoistStatic) {
    hoistStatic(root, context)
  }

  // 创建 root codegenNode 代码
  if (!options.ssr) {
    createRootCodegen(root, context)
  }

  // finalize meta information
  root.helpers = [...context.helpers.keys()]
  root.components = [...context.components]
  root.directives = [...context.directives]
  root.imports = context.imports
  root.hoists = context.hoists
  root.temps = context.temps
  root.cached = context.cached
}
#+end_src

其实到 [[createVNodeCall][createVNodeCall()]] 实现之后， transform 的主体逻辑就基本完成了，但是这个时
候还并不能使用，是因为 [[(context-nodeTransforms)][context.nodeTransforms]] 里此时还没内容，也就没法处理类型
~v-if,v-for,...~ 等等指令系统，这些指令都需要特殊相对应的 transform 函数来处理，这
些函数在 [[https://github.com/vuejs/core/blob/main/packages/compiler-core/src/transforms/][core/transforms at main · vuejs/core]] 下。

那这个 [[(context-nodeTransforms)][context.nodeTransforms]] 填充是在哪里呢(到调用 transform 的地方去
找-> [[https://github.com/vuejs/core/blob/main/packages/compiler-core/src/compile.ts][core/compile.ts at main · vuejs/core]], 因为这个包被调用都是通过 ~compile()~ 函
数调用的)？

所以这里加上这部分代码 -> [[baseCompile][baseCompile()]], 另外下面 ~transformXxx~ 函数的实现会根据
官方测试用例([[https://github.com/vuejs/core/blob/main/packages/compiler-core/__tests__/transform.spec.ts][core/transform.spec.ts at main · vuejs/core]])用到时候一个个来实现
([[transform-testing][testing->]])。

#+begin_tip
所有的 ~transformXxxx~ 开头的函数目的都是通过匹配到对应类型的元素/组件，然后返回一
个加工处理该 VNode 结构的函数，这些返回的函数会被按照一定顺序统一收集到一个数组
中，然后会在当前 AST 树被遍历结束之后，以加入时的逆序出来顺序执行(类似栈操作，收
集时入栈，执行时按出栈顺序执行。)
#+end_tip

** createTransformContext()

transform 上下文内容有点多，后面用到时再单独说明。

#+name: createTransformContext
#+begin_src js -n -r
function createTransformContext(
  root,
  {
    filename = '',
    prefixIdentifiers = false,
    hoistStatic = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    slotted = true,
    ssr = false,
    inSSR = false,
    ssrCssVars = ``,
    bindingMetadata = EMPTY_OBJ,
    inline = false,
    isTS = false,
    onError = defaultOnError,
    onWarn = defaultOnWarn,
    compatConfig
  }
) {
  const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/)
  const context = {
    // options
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    cacheHandlers,
    nodeTransforms, (ref:context-nodeTransforms)
    directiveTransforms, (ref:context-directiveTransforms)
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,

    // state
    root,
    helpers: new Map(),
    components: new Set(),
    directives: new Set(),
    hoists: [],
    imports: [],
    constantCache: new Map(),
    temps: 0,
    cached: 0,
    identifiers: Object.create(null),
    scopes: { // 记录下面四个指令的嵌套层次
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,

    // methods
    helper(name) { (ref:context-helper)
      const count = context.helpers.get(name) || 0
      context.helpers.set(name, count + 1)
      return name
    },
    removeHelper(name) { (ref:context-removeHelper)
      const count = context.helpers.get(name)
      if (count) {
        const currentCount = count - 1
        if (!currentCount) {
          context.helpers.delete(name)
        } else {
          context.helpers.set(name, currentCount)
        }
      }
    },
    helperString(name) { (ref:context-helperString)
      return `_${helperNameMap[context.helper(name)]}`
    },
    replaceNode(node) { (ref:context-replaceNode)
      context.parent.children[context.childIndex] = context.currentNode = node
    },
    removeNode(node) { (ref:context-removeNode)
      const list = context.parent.children
      const removalIndex = node
        ? list.indexOf(node)
        : context.currentNode
        ? context.childIndex
        : -1

      if (!node || node === context.currentNode) {
        // current node removed
        context.currentNode = null
        context.onNodeRemoved()
      } else {
        // sibling node removed
        if (context.childIndex > removalIndex) {
          context.childIndex--
          context.onNodeRemoved()
        }
      }
      context.parent.children.splice(removalIndex, 1)
    },
    onNodeRemoved: () => {},
    addIdentifiers(exp) {
      // identifier tracking only happens in non-browser builds.
      if (!__BROWSER__) {
        if (isString(exp)) {
          addId(exp)
        } else if (exp.identifiers) {
          exp.identifiers.forEach(addId)
        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
          addId(exp.content)
        }
      }
    },
    removeIdentifiers(exp) {
      if (!__BROWSER__) {
        if (isString(exp)) {
          removeId(exp)
        } else if (exp.identifiers) {
          exp.identifiers.forEach(removeId)
        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
          removeId(exp.content)
        }
      }
    },
    hoist(exp) { (ref:context-hoist)
      if (isString(exp)) exp = createSimpleExpression(exp)
      context.hoists.push(exp)
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        ConstantTypes.CAN_HOIST
      )
      identifier.hoisted = exp
      return identifier
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode)
    }
  }

  function addId(id) {
    const { identifiers } = context
    if (identifiers[id] === undefined) {
      identifiers[id] = 0
    }
    identifiers[id]++
  }

  function removeId(id) {
    context.identifiers[id]--
  }

  return context
}
#+end_src

** traverseNode()

遍历 ast root 树。

#+name: traverseNode
#+begin_src js -n -r
function traverseNode(node, context) {
  // 记录当前正在处理的节点
  context.currentNode = node
  // 对节点转换时使用到的插件(外部可通过这个来修改某个指令)
  const { nodeTransforms } = context
  // 递归遍历结束，回溯时调用的函数列表
  // 也就是这个函数最后执行的函数，当一颗树遍历完成执行的函数
  // 随后的 for 循环是用来收集这些函数的
  const exitFns = [] (ref:traverseNode-exitFns)

  logg('traverseNode', node)
  for (let i = 0; i < nodeTransforms.length; i++) { (ref:traverseNode-for-nodeTransforms)
    const onExit = nodeTransforms[i](node, context)
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit)
      } else {
        exitFns.push(onExit)
      }
    }
    if (!context.currentNode) {
      // node was removed
      return
    } else {
      // node may have been replaced
      node = context.currentNode
    }
  }

  // 根据节点类型来分别处理，这里忽略注释
  switch (node.type) {
    case NodeTypes.INTERPOLATION:
      // no need to traverse, but we need to inject toString helper
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING)
      }
      break

    // for container types, further traverse downwards
    // 处理 if...else if...else 分支
    case NodeTypes.IF:
      for (let i = 0; i < node.branches.length; i++) {
        traverseNode(node.branches[i], context)
      }
      break
    case NodeTypes.IF_BRANCH: // else..if
    case NodeTypes.FOR: // for
    case NodeTypes.ELEMENT:
    case NodeTypes.ROOT:
      traverseChildren(node, context)
      break
  }

  // 收集完成，执行这些收集到的函数，作用到当前节点上
  context.currentNode = node
  let i = exitFns.length
  while (i--) {
    exitFns[i]() (ref:traverseNode-exec-exitFns)
  }
}

#+end_src

** traverseChildren()

#+name: traverseChildren
#+begin_src js -n -r
function traverseChildren(parent, context) {
  let i = 0
  const nodeRemoved = () => {
    i--
  }
  for (; i < parent.children.length; i++) {
    const child = parent.children[i]
    if (isString(child)) continue
    context.parent = parent
    context.childIndex = i
    context.onNodeRemoved = nodeRemoved
    traverseNode(child, context)
  }
}
#+end_src

** hoistStatic()

#+name: hoistStatic
#+begin_src js -n -r
function hoistStatic() {}
#+end_src

** createRootCodegen()

#+name: createRootCodegen
#+begin_src js -n -r
function createRootCodegen(root, context) {
  const { helper } = context
  const { children } = root
  logg('createRootCodegen', `children=${children.length}, 只有一个用 block, 多个用Fragment`)
  if (children.length === 1) {
    const child = children[0]
    // if the single child is an element, turn it into a block.
    // 如果只有一个根元素，如： <template><div>...</div></template>
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // single element root is never hoisted so codegenNode will never be
      // SimpleExpressionNode
      const codegenNode = child.codegenNode
      if (codegenNode.type === NodeTypes.VNODE_CALL) {
        makeBlock(codegenNode, context)
      }
      root.codegenNode = codegenNode
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()
      root.codegenNode = child
    }
  } else if (children.length > 1) {
    // root 下有多个节点时，使用 fragment block，3.x 特性，2.x中是不支持多个元素的
    let patchFlag = PatchFlags.STABLE_FRAGMENT
    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]

    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      undefined,
      root.children,
      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),
      undefined,
      undefined,
      true,
      undefined,
      false /* isComponent */
    )
  } else {
    // no children = noop. codegen will return null.
  }
}
#+end_src
** createStructuralDirectiveTransform()

#+name: createStructuralDirectiveTransform
#+begin_src js -n -r
function createStructuralDirectiveTransform(name, fn) {
  // 正则就用 test 方法，字符串直接比较
  const matches = isString(name)
    ? (n) => n === name
    : (n) => name.test(n)

  logg('createStructuralDirectiveTransform', `name=${name}, matches=${matches}`)
  return (node, context) => {
    if (node.type === NodeTypes.ELEMENT) {
      const { props } = node
      // v-slot 指令特殊处理，代码在 vSlot.ts 中，所以这里跳过它
      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {
        return
      }
      const exitFns = []
      for (let i = 0; i < props.length; i++) {
        const prop = props[i]
        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {
          // structural directives are removed to avoid infinite recursion
          // also we remove them *before* applying so that it can further
          // traverse itself in case it moves the node around
          props.splice(i, 1)
          i--
          const onExit = fn(node, prop, context)
          if (onExit) exitFns.push(onExit)
        }
      }
      return exitFns
    }
  }
}

#+end_src

** Testing
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: transform-testing
:END:

#+name: transform-testing-utils
#+begin_src js -n -r
<<globalVars>>
<<baseParse>>
<<transform>>

function transformWithCodegen(template) {
  const ast = baseParse(template)
  transform(ast, {
    nodeTransforms: [
      transformIf,
      transformElement
    ]
  })

  return ast
}

function parseWithIfTransform(
  template,
  options = {},
  returnIndex = 0,
  childrenLen = 1
) {
  const ast = baseParse(template, options)
  transform(ast, {
    nodeTransforms: [transformIf, transformSlotOutlet, transformElement],
    ...options
  })
  if (!options.onError) {
    logg(`parseWithIfTransform| ast.children.length=${childrenLen}`, )
    for (let i = 0; i < childrenLen; i++) {
      logg(`parseWithIfTransform| NodeTypes.IF=${NodeTypes.IF}`,
          `ast.children[${i}].type=${ast.children[i].type}`)
    }
  }
  return {
    root: ast,
    node: ast.children[returnIndex]
  }
}

function parseWithSlots(template, options = {}) {
  const ast = baseParse(template)
  transform(ast, {
    nodeTransforms: [
      ...(options.prefixIdentifiers ? [transformExpression] : []),
      transformSlotOutlet,
      transformElement
    ],
    directiveTransforms: {
      // on: transformOn,
      // bind: transformBind
    },
    ...options
  })
  return ast
}

function transformWithTextOpt(template, options = {}) {
  const ast = baseParse(template)
  transform(ast, {
    nodeTransforms: [
      // transformFor,
      ...(options.prefixIdentifiers ? [transformExpression] : []),
      transformElement,
      transformText
    ],
    ...options
  })
  return ast
}

function parseWithForTransform(
  template,
  options = {}
) {
  const ast = baseParse(template, options)
  transform(ast, {
    nodeTransforms: [
      transformIf,
      transformFor,
      ...(options.prefixIdentifiers ? [transformExpression] : []),
      transformSlotOutlet,
      transformElement
    ],
    directiveTransforms: {
      // bind: transformBind
    },
    ...options
  })
  return {
    root: ast,
    node: ast.children[0]
  }
}

function transformWithOnce(template, options = {}) {
  const ast = baseParse(template)
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset()
  transform(ast, {
    nodeTransforms,
    directiveTransforms,
    ...options
  })
  return ast
}

function parseWithVBind(
  template,
  options = {}
) {
  const ast = baseParse(template)
  transform(ast, {
    nodeTransforms: [
      ...(options.prefixIdentifiers ? [transformExpression] : []),
      transformElement
    ],
    directiveTransforms: {
      bind: transformBind
    },
    ...options
  })
  return ast.children[0]
}

function parseWithVModel(template, options = {}) {
  const ast = baseParse(template)

  transform(ast, {
    nodeTransforms: [
      transformFor,
      transformExpression,
      transformElement,
      trackSlotScopes
    ],
    directiveTransforms: {
      ...options.directiveTransforms,
      model: transformModel
    },
    ...options
  })

  return ast
}

function parseWithVOn(template, options = {}) {
  const ast = baseParse(template, options)
  transform(ast, {
    nodeTransforms: [transformExpression, transformElement],
    directiveTransforms: {
      on: transformOn
    },
    ...options
  })
  return {
    root: ast,
    node: ast.children[0]
  }
}

function parseWithSlots(template, options = {}) {
  const ast = baseParse(template, {
    whitespace: options.whitespace
  })
  transform(ast, {
    nodeTransforms: [
      transformIf,
      transformFor,
      ...(options.prefixIdentifiers
        ? [trackVForSlotScopes, transformExpression]
        : []),
      transformSlotOutlet,
      transformElement,
      trackSlotScopes
    ],
    directiveTransforms: {
      on: transformOn,
      bind: transformBind
    },
    ...options
  })
  return {
    root: ast,
    slots:
      ast.children[0].type === NodeTypes.ELEMENT
        ? ast.children[0].codegenNode.children
        : null
  }
}

#+end_src

#+html: <br>
#+begin_details Testing :title-color red
#+name: transform-testing-calls
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const ast = baseParse(`<div>hello {{ world }}</div>`)
const calls = []
const plugin = (node, context) => {
  calls.push([node, { ...context }])
}

transform(ast, {
  nodeTransforms: [plugin]
})

const div = ast.children[0]
log(`calls.length=${calls.length}`)
calls.forEach((call, i) => logg(`call - ${i}`, call))
#+end_src

上面是完整的结构输出，精简之后：

<cyan:calls[0]> -> ~[ ast, { parent: null, currentNode: ast }]~  根节点，所以 ~parent=null~

<cyan:calls[1]> -> ~[ div, { parent: ast, currentNode: div }]~ 对应 div 节点，它的
parent 其实就是 root

<cyan:calls[2]> -> ~[ div.children[0], { parent: div, currentNode:
div.children[0] }]~, div 的第一个文本子节点 ~hello~

<cyan:calls[3]> -> ~[ div.children[1], { parent: div, currentNode:
div.children[1] }]~, div 的第二个插值子节点 ~{{ world }}~
#+end_details

#+html: <br>
#+begin_details Testing context.replaceNode :title-color red
[[(context-replaceNode)][replaceNode]]

#+name: transform-testing-replaceNode
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const ast = baseParse(`<div/><span/>`)

let n = 0
const plugin = (node, context) => {
  logg(`plugin - replaceNode - ${++n}`, `node.tag=${node.tag},node.type=${node.type}`)
  if (node.type === NodeTypes.ELEMENT && node.tag ===  'div') {
    context.replaceNode(Object.assign({}, node, {
      tag: 'p',
      children: [{
        type: NodeTypes.TEXT,
        content: 'hello',
        isEmpty: false
      }]
    }))
  }
}

transform(ast, {
  nodeTransforms: [plugin]
})

logg('ast.children.length', ast.children.length)
logg('new element', ast.children[0])
logg('called times', `n = ${n}`)
logg("children[0]", ast.children[0])
logg("children[1]", ast.children[1])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing context.removeNode :title-color red
[[(context-removeNode)][removeNode]]

#+name: transform-testing-removeNode
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const ast = baseParse(`<span/><div>hello</div><span/>`)
const c1 = ast.children[0]
const c2 = ast.children[1]
const c3 = ast.children[2]
const childCount = ast.children.length

logg(`child count: ${childCount}`)
logg('c1', c1)
logg('c2', c2)
logg('c3', c3)
logg('after')

let n = 0
const plugin = (node, context) => {
  logg(`plugin - removeNode - ${++n}`, `node.tag=${node.tag},node.type=${node.type}`)
  if (node.type === NodeTypes.ELEMENT && node.tag ===  'div') {
    context.removeNode()
  }
}

transform(ast, {
  nodeTransforms: [plugin]
})

logg('ast.children.length', ast.children.length)
logg('called times', `n = ${n}`)
logg(`children[0] ===  c1 ? ${ast.children[0] ===  c1}`)
logg(`children[1] ===  c3 ? ${ast.children[1] ===  c3}`)
logg("children[0]", ast.children[0])
logg("children[1]", ast.children[1])
logg("children[2]", ast.children[2])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing context.removeNode next sibling :title-color red
[[(context-removeNode)][removeNode]]

#+name: transform-testing-removeNode-sibling
#+begin_src js -n -r  :exports both
<<globalVars>>
<<baseParse>>
<<transform>>

const ast = baseParse(`<span/><div>hello</div><span/>`)
const c1 = ast.children[0]
const c2 = ast.children[1]
const c3 = ast.children[2]
const childCount = ast.children.length

logg(`child count: ${childCount}`)
logg('c1', c1)
logg('c2', c2)
logg('c3', c3)
logg('after')

let n = 0
const plugin = (node, context) => {
  logg(`plugin - removeNode - ${++n}`, `node.tag=${node.tag},node.type=${node.type}`)
  if (node.type === NodeTypes.ELEMENT && node.tag ===  'div') {
    context.removeNode()
    // 删除相邻节点，div在删除之前是 children[1] 删除之后它相邻的
    // span 就成了 children[1]
    context.removeNode(context.parent.children[1])
  }
}

transform(ast, {
  nodeTransforms: [plugin]
})

logg('ast.children.length', ast.children.length)
logg('called times', `n = ${n}`)
logg(`children[0] ===  c1 ? ${ast.children[0] ===  c1}`)
logg(`children[1] ===  c3 ? ${ast.children[1] ===  c3}`)
logg("children[0]", ast.children[0])
logg("children[1]", ast.children[1])
logg("children[2]", ast.children[2])
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing hoist TODO :title-color red

#+end_details
** transform plugins

transform 阶段遍历过程中使用到的一些 ~transformXxx~ 函数。

#+name: transform-plugins
#+begin_src js -n -r
<<makeBlock>>
<<buildSlots>>
<<transformElement>>
<<transformExpression>>
<<transformSlotOutlet>>
<<transformText>>
<<transformBind>>
<<transformFor>>
<<transformIf>>
<<transformMemo>>
<<transformModel>>
<<transformOn>>
<<transformOnce>>
<<processExpression>>
#+end_src

#+begin_tip
下面每个章节都是按照实现顺序排列，如： transformIf -> tranformSlotOutlet -> ...,
因为它们之间可能会有一定的依赖关系。
#+end_tip

*** makeBlock()

#+name: makeBlock
#+begin_src js -n -r
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true
    removeHelper(getVNodeHelper(inSSR, node.isComponent))
    helper(OPEN_BLOCK)
    helper(getVNodeBlockHelper(inSSR, node.isComponent))
  }
}
#+end_src
*** transformText()

通过 [[(isText)][isText()]] 来检查当前的 node.children 里面是不是包含相邻的文本节点(含插值)，
如果有就将它们合并，通过 ~+~ 相连接起来，如： ~{{ foo }} bar {{ baz }}~ => ~foo +
'bar' + bax~

#+name: transformText
#+begin_src js -n -r
// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
  if (
    node.type === NodeTypes.ROOT ||
    node.type === NodeTypes.ELEMENT ||
    node.type === NodeTypes.FOR ||
    node.type === NodeTypes.IF_BRANCH
  ) {
    // perform the transform on node exit so that all expressions have already
    // been processed.
    return () => {
      const children = node.children
      let currentContainer = undefined
      let hasText = false

      for (let i = 0; i < children.length; i++) {
        const child = children[i]
        if (isText(child)) {
          hasText = true
          for (let j = i + 1; j < children.length; j++) { (ref:transformText-for-start)
            const next = children[j]
            if (isText(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = {
                  type: NodeTypes.COMPOUND_EXPRESSION,
                  loc: child.loc,
                  children: [child]
                }
              }
              // merge adjacent text node into current
              currentContainer.children.push(` + `, next)
              children.splice(j, 1)
              j--
            } else {
              currentContainer = undefined
              break
            }
          } (ref:transformText-for-end)
        }
      }

      if (
        !hasText ||
        // if this is a plain element with a single text child, leave it
        // as-is since the runtime has dedicated fast path for this by directly
        // setting textContent of the element.
        // for component root it's always normalized anyway.
        (children.length === 1 &&
          (node.type === NodeTypes.ROOT ||
            (node.type === NodeTypes.ELEMENT &&
              node.tagType === ElementTypes.ELEMENT &&
              // #3756
              // custom directives can potentially add DOM elements arbitrarily,
              // we need to avoid setting textContent of the element at runtime
              // to avoid accidentally overwriting the DOM elements added
              // by the user through custom directives.
              !node.props.find(
                p =>
                  p.type === NodeTypes.DIRECTIVE &&
                  !context.directiveTransforms[p.name]
              ))))
      ) {
        return
      }

      // pre-convert text nodes into createTextVNode(text) calls to avoid
      // runtime normalization.
      for (let i = 0; i < children.length; i++) {
        const child = children[i]
        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {
          const callArgs = []
          // createTextVNode defaults to single whitespace, so if it is a
          // single space the code could be an empty call to save bytes.
          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {
            callArgs.push(child)
          }
          // mark dynamic text with flag so it gets patched inside a block
          if (
            !context.ssr &&
            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT
          ) {
            callArgs.push(
              PatchFlags.TEXT +
                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)
            )
          }
          children[i] = {
            type: NodeTypes.TEXT_CALL,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          }
        }
      }
    }
  }
}
#+end_src

red:Testing

#+html: <br>
#+begin_details interpolation :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

const root = transformWithTextOpt(`{{ foo }}`)
logg('root.children[0]', root.children[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details 连续 text :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

const root = transformWithTextOpt(`{{ foo }} bar {{ baz }}`)
logg('root.children[0]', root.children[0])
const childs = root.children[0].children
logg('childs[0]', childs[0])
logg('childs[1]', childs[1])
logg('childs[2]', childs[2])
logg('childs[3]', childs[3])
logg('childs[4]', childs[4])
#+end_src
#+end_details

*** transformElement()

#+name: transformElement
#+begin_src js -n -r
// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap()

// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
  // perform the work on exit, after all child expressions have been
  // processed and merged.
  return function postTransformElement() {
    node = context.currentNode

    if (
      !(
        node.type === NodeTypes.ELEMENT &&
        (node.tagType === ElementTypes.ELEMENT ||
          node.tagType === ElementTypes.COMPONENT)
      )
    ) {
      return
    }

    const { tag, props } = node
    const isComponent = node.tagType === ElementTypes.COMPONENT

    // The goal of the transform is to create a codegenNode implementing the
    // VNodeCall interface.
    let vnodeTag = isComponent
      ? resolveComponentType(node, context)
      : `"${tag}"`

    const isDynamicComponent =
      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT

    let vnodeProps
    let vnodeChildren
    let vnodePatchFlag
    let patchFlag = 0
    let vnodeDynamicProps
    let dynamicPropNames
    let vnodeDirectives

    let shouldUseBlock =
      // dynamic component may resolve to plain elements
      isDynamicComponent ||
      vnodeTag === TELEPORT ||
      vnodeTag === SUSPENSE ||
      (!isComponent &&
        // <svg> and <foreignObject> must be forced into blocks so that block
        // updates inside get proper isSVG flag at runtime. (#639, #643)
        // This is technically web-specific, but splitting the logic out of core
        // leads to too much unnecessary complexity.
        (tag === 'svg' || tag === 'foreignObject'))

    // props
    if (props.length > 0) {
      const propsBuildResult = buildProps(node, context)
      vnodeProps = propsBuildResult.props
      patchFlag = propsBuildResult.patchFlag
      dynamicPropNames = propsBuildResult.dynamicPropNames
      const directives = propsBuildResult.directives
      vnodeDirectives =
        directives && directives.length
          ? (createArrayExpression(
              directives.map(dir => buildDirectiveArgs(dir, context))
            ))
          : undefined

      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true
      }
    }

    // children
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        // Although a built-in component, we compile KeepAlive with raw children
        // instead of slot functions so that it can be used inside Transition
        // or other Transition-wrapping HOCs.
        // To ensure correct updates with block optimizations, we need to:
        // 1. Force keep-alive into a block. This avoids its children being
        //    collected by a parent block.
        shouldUseBlock = true
        // 2. Force keep-alive to always be updated, since it uses raw children.
        patchFlag |= PatchFlags.DYNAMIC_SLOTS
      }

      const shouldBuildAsSlots =
        isComponent &&
        // Teleport is not a real component and has dedicated runtime handling
        vnodeTag !== TELEPORT &&
        // explained above.
        vnodeTag !== KEEP_ALIVE

      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context)
        vnodeChildren = slots
        if (hasDynamicSlots) {
          patchFlag |= PatchFlags.DYNAMIC_SLOTS
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0]
        const type = child.type
        // check for dynamic text children
        const hasDynamicTextChild =
          type === NodeTypes.INTERPOLATION ||
          type === NodeTypes.COMPOUND_EXPRESSION
        if (
          hasDynamicTextChild &&
          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT
        ) {
          patchFlag |= PatchFlags.TEXT
        }
        // pass directly if the only child is a text node
        // (plain / interpolation / expression)
        if (hasDynamicTextChild || type === NodeTypes.TEXT) {
          vnodeChildren = child
        } else {
          vnodeChildren = node.children
        }
      } else {
        vnodeChildren = node.children
      }
    }

    // patchFlag & dynamicPropNames
    if (patchFlag !== 0) {
      vnodePatchFlag = String(patchFlag)
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)
      }
    }

    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      vnodePatchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false /* disableTracking */,
      isComponent,
      node.loc
    )
  }
}

function resolveComponentType(
  node,
  context,
  ssr = false
) {
  let { tag } = node

  // 1. dynamic component
  const isExplicitDynamic = isComponentTag(tag)
  const isProp = findProp(node, 'is')
  if (isProp) {
    if (isExplicitDynamic ) {
      const exp =
        isProp.type === NodeTypes.ATTRIBUTE
          ? isProp.value && createSimpleExpression(isProp.value.content, true)
          : isProp.exp
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ])
      }
    } else if (
      isProp.type === NodeTypes.ATTRIBUTE &&
      isProp.value.content.startsWith('vue:')
    ) {
      // <button is="vue:xxx">
      // if not <component>, only is value that starts with "vue:" will be
      // treated as component by the parse phase and reach here, unless it's
      // compat mode where all is values are considered components
      tag = isProp.value.content.slice(4)
    }
  }

  // 1.5 v-is (TODO: Deprecate)
  const isDir = !isExplicitDynamic && findDir(node, 'is')
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ])
  }

  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)
  if (builtIn) {
    // built-ins are simply fallthroughs / have special handling during ssr
    // so we don't need to import their runtime equivalents
    if (!ssr) context.helper(builtIn)
    return builtIn
  }

  // 3. user component (from setup bindings)
  // this is skipped in browser build since browser builds do not perform
  // binding analysis.
  if (!__BROWSER__) {
    const fromSetup = resolveSetupReference(tag, context)
    if (fromSetup) {
      return fromSetup
    }
    const dotIndex = tag.indexOf('.')
    if (dotIndex > 0) {
      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)
      if (ns) {
        return ns + tag.slice(dotIndex)
      }
    }
  }

  // 4. Self referencing component (inferred from filename)
  if (
    !__BROWSER__ &&
    context.selfName &&
    capitalize(camelize(tag)) === context.selfName
  ) {
    context.helper(RESOLVE_COMPONENT)
    // codegen.ts has special check for __self postfix when generating
    // component imports, which will pass additional `maybeSelfReference` flag
    // to `resolveComponent`.
    context.components.add(tag + `__self`)
    return toValidAssetId(tag, `component`)
  }

  // 5. user component (resolve)
  context.helper(RESOLVE_COMPONENT)
  context.components.add(tag)
  return toValidAssetId(tag, `component`)
}


function resolveSetupReference(name, context) {
  const bindings = context.bindingMetadata
  if (!bindings || bindings.__isScriptSetup === false) {
    return
  }

  const camelName = camelize(name)
  const PascalName = capitalize(camelName)
  const checkType = (type) => {
    if (bindings[name] === type) {
      return name
    }
    if (bindings[camelName] === type) {
      return camelName
    }
    if (bindings[PascalName] === type) {
      return PascalName
    }
  }

  const fromConst = checkType(BindingTypes.SETUP_CONST)
  if (fromConst) {
    return context.inline
      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is
        fromConst
      : `$setup[${JSON.stringify(fromConst)}]`
  }

  const fromMaybeRef =
    checkType(BindingTypes.SETUP_LET) ||
    checkType(BindingTypes.SETUP_REF) ||
    checkType(BindingTypes.SETUP_MAYBE_REF)
  if (fromMaybeRef) {
    return context.inline
      ? // setup scope bindings that may be refs need to be unrefed
        `${context.helperString(UNREF)}(${fromMaybeRef})`
      : `$setup[${JSON.stringify(fromMaybeRef)}]`
  }
}

function buildProps(
  node,
  context,
  props = node.props,
  ssr = false
) {
  const { tag, loc: elementLoc, children } = node
  const isComponent = node.tagType === ElementTypes.COMPONENT
  let properties = []
  const mergeArgs = []
  const runtimeDirectives = []
  const hasChildren = children.length > 0
  let shouldUseBlock = false

  // patchFlag analysis
  let patchFlag = 0
  let hasRef = false
  let hasClassBinding = false
  let hasStyleBinding = false
  let hasHydrationEventBinding = false
  let hasDynamicKeys = false
  let hasVnodeHook = false
  const dynamicPropNames = []

  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content
      const isEventHandler = isOn(name)
      if (
        !isComponent &&
        isEventHandler &&
        // omit the flag for click handlers because hydration gives click
        // dedicated fast path.
        name.toLowerCase() !== 'onclick' &&
        // omit v-model handlers
        name !== 'onUpdate:modelValue' &&
        // omit onVnodeXXX hooks
        !isReservedProp(name)
      ) {
        hasHydrationEventBinding = true
      }

      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true
      }

      if (
        value.type === NodeTypes.JS_CACHE_EXPRESSION ||
        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||
          value.type === NodeTypes.COMPOUND_EXPRESSION) &&
          getConstantType(value, context) > 0)
      ) {
        // skip if the prop is a cached handler or has constant value
        return
      }

      if (name === 'ref') {
        hasRef = true
      } else if (name === 'class') {
        hasClassBinding = true
      } else if (name === 'style') {
        hasStyleBinding = true
      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name)
      }

      // treat the dynamic class and style binding of the component as dynamic props
      if (
        isComponent &&
        (name === 'class' || name === 'style') &&
        !dynamicPropNames.includes(name)
      ) {
        dynamicPropNames.push(name)
      }
    } else {
      hasDynamicKeys = true
    }
  }

  for (let i = 0; i < props.length; i++) {
    // static attribute
    const prop = props[i]
    if (prop.type === NodeTypes.ATTRIBUTE) {
      const { loc, name, value } = prop
      let isStatic = true
      if (name === 'ref') {
        hasRef = true
        if (context.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression('ref_for', true),
              createSimpleExpression('true')
            )
          )
        }
        // in inline mode there is no setupState object, so we can't use string
        // keys to set the ref. Instead, we need to transform it to pass the
        // actual ref instead.
        if (
          !__BROWSER__ &&
          value &&
          context.inline &&
          context.bindingMetadata[value.content]
        ) {
          isStatic = false
          properties.push(
            createObjectProperty(
              createSimpleExpression('ref_key', true),
              createSimpleExpression(value.content, true, value.loc)
            )
          )
        }
      }
      // skip is on <component>, or is="vue:xxx"
      if (
        name === 'is' &&
        (isComponentTag(tag) ||
          (value && value.content.startsWith('vue:')))
      ) {
        continue
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(
            name,
            true,
            getInnerRange(loc, 0, name.length)
          ),
          createSimpleExpression(
            value ? value.content : '',
            isStatic,
            value ? value.loc : loc
          )
        )
      )
    } else {
      // directives
      const { name, arg, exp, loc } = prop
      const isVBind = name === 'bind'
      const isVOn = name === 'on'

      // skip v-slot - it is handled by its dedicated transform.
      if (name === 'slot') {
        continue
      }
      // skip v-once/v-memo - they are handled by dedicated transforms.
      if (name === 'once' || name === 'memo') {
        continue
      }
      // skip v-is and :is on <component>
      if (
        name === 'is' ||
        (isVBind &&
          isStaticArgOf(arg, 'is') &&
          isComponentTag(tag))
      ) {
        continue
      }
      // skip v-on in SSR compilation
      if (isVOn && ssr) {
        continue
      }

      if (
        // #938: elements with dynamic keys should be forced into blocks
        (isVBind && isStaticArgOf(arg, 'key')) ||
        // inline before-update hooks need to force block so that it is invoked
        // before children
        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))
      ) {
        shouldUseBlock = true
      }

      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression('ref_for', true),
            createSimpleExpression('true')
          )
        )
      }

      // special case for v-bind and v-on with no argument
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true
        if (exp) {
          if (properties.length) {
            mergeArgs.push(
              createObjectExpression(dedupeProperties(properties), elementLoc)
            )
            properties = []
          }
          if (isVBind) {
            mergeArgs.push(exp)
          } else {
            // v-on="obj" -> toHandlers(obj)
            mergeArgs.push({
              type: NodeTypes.JS_CALL_EXPRESSION,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            })
          }
        }
        continue
      }

      const directiveTransform = context.directiveTransforms[name]
      if (directiveTransform) {
        // has built-in directive transform.
        const { props, needRuntime } = directiveTransform(prop, node, context)
        !ssr && props.forEach(analyzePatchFlag)
        properties.push(...props)
        if (needRuntime) {
          runtimeDirectives.push(prop)
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime)
          }
        }
      } else if (!isBuiltInDirective(name)) {
        // no built-in transform, this is a user custom directive.
        runtimeDirectives.push(prop)
        // custom dirs may use beforeUpdate so they need to force blocks
        // to ensure before-update gets called before children update
        if (hasChildren) {
          shouldUseBlock = true
        }
      }
    }
  }

  let propsExpression = undefined

  // has v-bind="object" or v-on="object", wrap with mergeProps
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      )
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      )
    } else {
      // single v-bind with nothing else - no need for a mergeProps call
      propsExpression = mergeArgs[0]
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    )
  }

  // patchFlag analysis
  if (hasDynamicKeys) {
    patchFlag |= PatchFlags.FULL_PROPS
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= PatchFlags.CLASS
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= PatchFlags.STYLE
    }
    if (dynamicPropNames.length) {
      patchFlag |= PatchFlags.PROPS
    }
    if (hasHydrationEventBinding) {
      patchFlag |= PatchFlags.HYDRATE_EVENTS
    }
  }
  if (
    !shouldUseBlock &&
    (patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &&
    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)
  ) {
    patchFlag |= PatchFlags.NEED_PATCH
  }

  // pre-normalize props, SSR is skipped for now
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case NodeTypes.JS_OBJECT_EXPRESSION:
        // means that there is no v-bind,
        // but still need to deal with dynamic key binding
        let classKeyIndex = -1
        let styleKeyIndex = -1
        let hasDynamicKey = false

        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key
          if (isStaticExp(key)) {
            if (key.content === 'class') {
              classKeyIndex = i
            } else if (key.content === 'style') {
              styleKeyIndex = i
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true
          }
        }

        const classProp = propsExpression.properties[classKeyIndex]
        const styleProp = propsExpression.properties[styleKeyIndex]

        // no dynamic key
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            )
          }
          if (
            styleProp &&
            !isStaticExp(styleProp.value) &&
            // the static style is compiled into an object,
            // so use `hasStyleBinding` to ensure that it is a dynamic style binding
            (hasStyleBinding ||
              // v-bind:style and style both exist,
              // v-bind:style with static literal object
              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)
          ) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            )
          }
        } else {
          // dynamic key binding, wrap with `normalizeProps`
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          )
        }
        break
      case NodeTypes.JS_CALL_EXPRESSION:
        // mergeProps call, do nothing
        break
      default:
        // single v-bind
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        )
        break
    }
  }

  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  }
}

// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
  const knownProps = new Map()
  const deduped = []
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i]
    // dynamic keys are always allowed
    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {
      deduped.push(prop)
      continue
    }
    const name = prop.key.content
    const existing = knownProps.get(name)
    if (existing) {
      if (name === 'style' || name === 'class' || isOn(name)) {
        mergeAsArray(existing, prop)
      }
      // unexpected duplicate, should have emitted error during parse
    } else {
      knownProps.set(name, prop)
      deduped.push(prop)
    }
  }
  return deduped
}

function mergeAsArray(existing, incoming) {
  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {
    existing.value.elements.push(incoming.value)
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    )
  }
}

function buildDirectiveArgs(
  dir,
  context
) {
  const dirArgs = []
  const runtime = directiveImportMap.get(dir)
  if (runtime) {
    // built-in directive with runtime
    dirArgs.push(context.helperString(runtime))
  } else {
    // user directive.
    // see if we have directives exposed via <script setup>
    const fromSetup =
      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)
    if (fromSetup) {
      dirArgs.push(fromSetup)
    } else {
      // inject statement for resolving directive
      context.helper(RESOLVE_DIRECTIVE)
      context.directives.add(dir.name)
      dirArgs.push(toValidAssetId(dir.name, `directive`))
    }
  }
  const { loc } = dir
  if (dir.exp) dirArgs.push(dir.exp)
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`)
    }
    dirArgs.push(dir.arg)
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`)
      }
      dirArgs.push(`void 0`)
    }
    const trueExpression = createSimpleExpression(`true`, false, loc)
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(modifier =>
          createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    )
  }
  return createArrayExpression(dirArgs, dir.loc)
}

function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i])
    if (i < l - 1) propsNamesString += ', '
  }
  return propsNamesString + `]`
}

function isComponentTag(tag) {
  return tag === 'component' || tag === 'Component'
}


#+end_src
*** transformIf()

对于 ~v-if|else|else-if~ 指令在 [[transform][transform()]] 阶段，转换收集 ~transformXxx~ 函数过程中，
会先针对指令进行处理，比如： ~v-else~, ~v-else-if~ 指令的组件会被解析到 ~v-if~ 节点的
~node.branches[]~ 分支数组里面之后被删除，这些都是在收集 ~transformXxx~ 之前需要完成
的。

#+begin_important
这里的处理步骤：

1. 先找到 ~v-if~ 分支，创建一个 ~NodeTypes.IF~ 类型结点，并用这个新建的去替换
   ([[(context-replaceNode)][replaceNode()]])掉 ~v-if~ 这个结点

   #+begin_src typescript
    const ifNode: IfNode = {
      type: NodeTypes.IF,
      loc: node.loc,
      branches: [branch]
    }
   #+end_src

2. 如果是 ~v-else-*~ 分支，则需要先找到 *1* 步中的 ~v-if~ 分支，也就是它的依赖分支。然
   后直接将当前分支从主树中删除，放到 ~ifNode.branches~ 中，然后手动执行一次
   [[traverseNode][traverseNode()]] 再直接执行 ~onExit=prcessCodegen(sibling, branch, false)~ 返回的
   [[(processIf-onExit)][onExit]] 函数，去解析出该分支的 ~codegenNode~ ，这个 onExit 函数其实就是[[tranformIf][tranformIf()]]
   中这部分代码 [[(transformIf-exitFn-start)]]到[[(transformIf-exitFn-end)]] 。

   注意看下面代码([[processIf][processIf()]]:[[(processIf-IF-start)]]~[[(processIf-IF-end)]]):

   #+begin_src js -n -r
    if (sibling && sibling.type === NodeTypes.IF) {
        // 这里会将原本的结点删除，而是用新组装的 if 结构(包含else-if, else 分支的结构，node.branches[...])
        context.removeNode()
        const branch = createIfBranch(node, dir)
        sibling.branches.push(branch)

        const onExit = processCodegen && processCodegen(sibling, branch, false)
        // 这里需要手动触发一次遍历，因为上面将原本的分支节点从原来的节点树中删除了
        traverseNode(branch, context)
        // 回溯结束后执行收集到的 transformXxx 函数
        if (onExit) onExit()
        // make sure to reset currentNode after traversal to indicate this
        // node has been removed.
        context.currentNode = null
      }
      break
    }
   #+end_src

3. 最后记得 ~context.currentNode = null~ 标记 ~v-else-*~ 分支已经被删除了。
#+end_important

包括 [[transformFor][v-for]] 指令都需要经过 [[createStructuralDirectiveTransform][createStructuralDirectiveTransform()]] 函数封装一层 之后，
返回对应的 ~transformXxx~ 函数。

#+name: transformIf
#+begin_src js -n -r
<<processIf>>
<<createIfBranch>>
<<createCodegenNodeForBranch>>
<<createChildrenCodegenNode>>
<<isSameKey>>
<<getParentCondition>>

const transformIf = createStructuralDirectiveTransform(
  /^(if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children
      // if...else if...else 都处于同级渲染
      let i = siblings.indexOf(ifNode)
      let key = 0
      while (i-- >= 0) {
        const sibling = siblings[i]
        if (sibling && sibling.type === NodeTypes.IF) {
          key += sibling.branches.length
        }
      }

      logg('transformIf', ifNode, { isRoot, branch })
      // 退出时的回调，当所有 children 被遍历转换完成时被调用生成 codegenNode
      return () => { (ref:transformIf-exitFn-start)
        if (isRoot) { // v-if
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch, key, context
          )
          logg('transformIf - isRoot - v-if', ifNode)
        } else { // v-else, v-else-if
          // 将 v-else-* 分枝挂到 v-if 节点下面
          const parentCondition = getParentCondition(ifNode.codegenNode)
          parentCondition.alternate = createCodegenNodeForBranch(
            branch, key + ifNode.branches.length - 1,
            context
          )
          logg('transformIf - v-else-*', ifNode)
        }
      } (ref:transformIf-exitFn-end)

    })
  }
)
#+end_src

流程图：

#+begin_export html
<a href="../assets/img/vue3plus/d/transform-v-if.svg"
data-fancybox="gallery"
data-caption="Preview"
><img src="../assets/img/vue3plus/d/transform-v-if.svg"/></a>
#+end_export

文字描述：

~<div v-if="foo" /><p v-else-if="bar" /><span v-else />~

代码过程(省略部分解析流程，主要突出 ~v-if,v-else-*~ 指令解析)：

[[transform][transform()]] -> [[traverseNode][traverseNode()]] -> [[transformIf][transformIf()]] -> [[(traverseNode-exitFns)][exitFns[<transformIf>]​]] -> ...

[[transformIf][transformIf()]] -> [[processIf][processIf()]] -> 新建 [[(processIf-ifNode)][NodeTypes.IF#ifNode]] -> 替换 [[(processIf-replaceNode)][div#v-if]] -> push
~ifNode.branches[<div#v-if>]~

~p#v-else-if~ -> 从 [[(processIf-removeNode)][root ast]] 中删除 -> push [[(processIf-push-branch)][ifNode.branches[<div#v-if>,
<p#v-else-if>]]] -> 重新 [[traverseNode][traverseNode(<p#v-else-if>)]] -> 生成 [[(processIf-onExit)][codegeNode]]

~span#v-else~ -> 从 [[(processIf-removeNode)][root ast]] 中删除 -> push [[(processIf-push-branch)][ifNode.branches[<div#v-if>,
<p#v-else-if>, <span#v-else>]​]] -> 重新 [[traverseNode][traverseNode(<span#v-else>)]] -> 生成 [[(processIf-onExit)][codegeNode]]

最后退出收集过程，退出 [[(traverseNode-for-nodeTransforms)][for#exitFns]] 循环执行收集到的 [[(traverseNode-exec-exitFns)][exitFns<fn for ifNode>]],
[[transformIf][tranformIf:processCodegen]]:[[(transformIf-exitFn-start)]]~[[(transformIf-exitFn-end)]]

red:Testing

#+html: <br>
#+begin_details Testing v-if :title-color red

#+begin_box
red:BUG1:

TypeError: Cannot read properties of undefined (reading 'type')

    at getMemoedVNodeCall (/Users/gcl/tmp/test/transform.js:468:12)

    at createChildrenCodegenNode (/Users/gcl/tmp/test/transform.js:2532:23)

A. 是因为没有实现 [[transformElement][transformElement()]] 导致 ~div.codegenNode~  是 ~undefined~
#+end_box

#+name: transform-testing-v-if
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const ast = transformWithCodegen("<div v-if='ok' />")
logg('AST', ast)
logg('root.codgenNode', ast.codegenNode)
logg('div.codgenNode', ast.children[0].codegenNode)
#+end_src

对于 v-if 节点会生成如下 codegenNode:

#+begin_src js -n -r
 codegenNode: {
    type: 19,
    test: {
      type: 4,
      content: 'ok',
      isStatic: false,
      constType: 0,
      loc: [Object]
    },
    consequent: {
      type: 13,
      tag: '"div"',
      props: [Object],
      children: undefined,
      patchFlag: undefined,
      dynamicProps: undefined,
      directives: undefined,
      isBlock: true,
      disableTracking: false,
      isComponent: false,
      loc: [Object]
    },
    alternate: {
      type: 14,
      loc: [Object],
      callee: Symbol(createCommentVNode),
      arguments: [Array]
    },
    newline: true,
    loc: { source: '', start: [Object], end: [Object] }
  }
#+end_src

pink:test 是 ~v-if="ok"~ 的值解析出来的结构

pink:consequent 是 ~ok~ 值为真值时渲染的主分支节点(即 ~div~)

pink:alternate 是 ~v-else-if, v-else~ 分支，这里因为只有 ~v-if~ 所以是一个默认的注释
节点(如果有 ~v-else-if~ 分支它的结构会是 ~alternate: { ..., alternate: {...} }~ 嵌套
模式，如后面多分支的 ~v-if~ [[transform-testing-v-ifs][测试用例]])。
#+end_details

#+html: <br>
#+begin_details Testing v-ifs :title-color red
#+name: transform-testing-v-ifs
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const ast = transformWithCodegen("<div v-if='foo' /><span v-else-if='bar' /><p v-else />")
logg('AST', ast)
logg('root.codgenNode', ast.codegenNode)
const div = ast.codegenNode.codegenNode
logg('div.codegenNode - div#v-if', div)
logg('div.codegenNode.test - div#foo', div.test)
logg('div.codegenNode.consequent - div#v-if', div.consequent)
logg('div.codegenNode.alternate - span', div.alternate)
logg('div.codegenNode.alternate.test - span#bar', div.alternate.test)
logg('div.codegenNode.alternate.consequent - span#v-else-if', div.alternate.consequent)
logg('div.codegenNode.alternate.alternate - p#v-else', div.alternate.alternate)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing v-if with template :title-color red
#+name: transform-testing-v-if-template
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node, root } = parseWithIfTransform("<template v-if='ok'><div/>hello<p/></template>")
logOn()
logg('root ast', root)
logg(`node.type=${node.type}, NodeTypes.IF=${NodeTypes.IF}`)
logg(`node.branches.length=${node.branches.length}`)
logg(`node.branches[0]`, node.branches[0])
logg(`node.branches[0].children.length=${node.branches[0].children.length}`)
node.branches[0].children.forEach(( child, i ) => {
  logg(`node.branches[0].children[${i}]`, child)
})

#+end_src
#+end_details

#+html: <br>
#+begin_details Testing v-if with component :title-color red
#+name: transform-testing-v-if-component
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const { node, root } = parseWithIfTransform("<Component v-if='ok'></Component>")
logg('root ast', root)
logg(`node.type=${node.type}, NodeTypes.IF=${NodeTypes.IF}`)
logg(`node.branches.length=${node.branches.length}`)
logg(`node.branches[0]`, node.branches[0])
logg(`node.branches[0].children.length=${node.branches[0].children.length}`)
node.branches[0].children.forEach(( child, i ) => {
  logg(`node.branches[0].children[${i}]`, child)
})

#+end_src

#+end_details

#+html: <br>
#+begin_details Testing should prefix v-if condition :title-color red

将表达式内容( ~content:'ok'~ )加上 ~content:'_ctx.ok'~

#+name: transform-testing-v-if-prefix-condition
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const { node, root } = parseWithIfTransform("<div v-if='ok'></div>", {prefixIdentifiers: true})
logg('root ast', root)
logg(`node.type=${node.type}, NodeTypes.IF=${NodeTypes.IF}`)
logg(`node.branches.length=${node.branches.length}`)
logg(`node.branches[0]`, node.branches[0])
logg(`node.branches[0].condition`, node.branches[0].condition)
#+end_src
#+end_details


**** processIf()

初始化 ~v-if~ process 函数， ~processIf~ 函数里面会针对 ~v-if~ 节点甚至它的兄弟节点做
一系列操作，比如将下一个是 ~v-else~ 的兄弟节点删除移到自己的 ~branches[]~ 里面。

#+name: processIf
#+begin_src js -n -r
function processIf(node, dir, context, processCodegen) {
  logg('processIf - node - dir', node, dir)
  if (
    dir.name !== 'else' &&
    (!dir.exp || !dir.exp.content.trim())
  ) {
    const loc = dir.exp ? dir.exp.loc : node.loc
    // <div v-if></div> 没有指令值的情况，默认值为 true
    dir.exp = createSimpleExpression(`true`, false, loc)
  }

  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {
    // dir.exp can only be simple expression because vIf transform is applied
    // before expression transform.
    dir.exp = processExpression(dir.exp, context)
  }

  if (dir.name === 'if') { // v-if
    const branch = createIfBranch(node, dir)
    const ifNode = { (ref:processIf-ifNode)
      type: NodeTypes.IF,
      loc: node.loc,
      branches: [branch] (ref:processIf-branches)
    }
    context.replaceNode(ifNode) (ref:processIf-replaceNode)
    if (processCodegen) {
      return processCodegen(ifNode, branch, true)
    }
  } else {
    // locate the adjacent v-if
    const siblings = context.parent.children
    const comments = []
    let i = siblings.indexOf(node)
    while (i-- >= -1) {
      const sibling = siblings[i]

      // 空行，空文本
      if (
        sibling &&
        sibling.type === NodeTypes.TEXT &&
        !sibling.content.trim().length
      ) {
        context.removeNode(sibling)
        continue
      }

      if (sibling && sibling.type === NodeTypes.IF) { (ref:processIf-IF-start)
        // 这里会将原本的结点删除，而是用新组装的 if 结构(包含else-if, else 分支的结构，node.branches[...])
        context.removeNode() (ref:processIf-removeNode)
        const branch = createIfBranch(node, dir)
        sibling.branches.push(branch) (ref:processIf-push-branch)

        const onExit = processCodegen && processCodegen(sibling, branch, false) (ref:processIf-onExit)
        // 这里需要手动触发一次遍历，因为上面将原本的分支节点从原来的节点树中删除了
        traverseNode(branch, context)
        // 回溯结束后执行收集到的 transformXxx 函数
        if (onExit) onExit()
        // make sure to reset currentNode after traversal to indicate this
        // node has been removed.
        context.currentNode = null
      } (ref:processIf-IF-end)
      break
    }
  }
}
#+end_src

其中 [[(processIf-branches)][branches]] 保存着所有 ~v-else~, ~v-else-if~ 分支节点，这里其实是创建了一个默认的
分支节点(注释结点)，因为 ~v-if~ 系列指令在 render 函数中是以三元运算符(~?:~)形式存在
的，所以 if 后面必须要有一个分支，即 ~condition ? node1 : node2~ 中的 node2 必须是
个有效的值，才能正常使用 ~?:~ 运算符。

**** processExpression()

#+name: processExpression
#+begin_src js -n -r
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !__BROWSER__ check so that it can be
// tree-shaken from the browser build.
function processExpression(
  node,
  context,
  // some expressions like v-slot props & v-for aliases should be parsed as
  // function params
  asParams = false,
  // v-on handler values may contain multiple statements
  asRawStatements = false,
  localVars = Object.create(context.identifiers)
) {
  if (__BROWSER__) {
    return node
  }

  if (!context.prefixIdentifiers || !node.content.trim()) {
    return node
  }

  const { inline, bindingMetadata } = context
  const rewriteIdentifier = (raw, parent, id) => {
    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]
    if (inline) {
      // x = y
      const isAssignmentLVal =
        parent && parent.type === 'AssignmentExpression' && parent.left === id
      // x++
      const isUpdateArg =
        parent && parent.type === 'UpdateExpression' && parent.argument === id
      // ({ x } = y)
      const isDestructureAssignment =
        parent && isInDestructureAssignment(parent, parentStack)

      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {
        return raw
      } else if (type === BindingTypes.SETUP_REF) {
        return `${raw}.value`
      } else if (type === BindingTypes.SETUP_MAYBE_REF) {
        // const binding that may or may not be ref
        // if it's not a ref, then assignments don't make sense -
        // so we ignore the non-ref assignment case and generate code
        // that assumes the value to be a ref for more efficiency
        return isAssignmentLVal || isUpdateArg || isDestructureAssignment
          ? `${raw}.value`
          : `${context.helperString(UNREF)}(${raw})`
      } else if (type === BindingTypes.SETUP_LET) {
        if (isAssignmentLVal) {
          // let binding.
          // this is a bit more tricky as we need to cover the case where
          // let is a local non-ref value, and we need to replicate the
          // right hand side value.
          // x = y --> isRef(x) ? x.value = y : x = y
          const { right: rVal, operator } = parent
          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1)
          const rExpString = stringifyExpression(
            processExpression(
              createSimpleExpression(rExp, false),
              context,
              false,
              false,
              knownIds
            )
          )
          return `${context.helperString(IS_REF)}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`
        } else if (isUpdateArg) {
          // make id replace parent in the code range so the raw update operator
          // is removed
          id.start = parent.start
          id.end = parent.end
          const { prefix: isPrefix, operator } = parent
          const prefix = isPrefix ? operator : ``
          const postfix = isPrefix ? `` : operator
          // let binding.
          // x++ --> isRef(a) ? a.value++ : a++
          return `${context.helperString(IS_REF)}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`
        } else if (isDestructureAssignment) {
          // TODO
          // let binding in a destructure assignment - it's very tricky to
          // handle both possible cases here without altering the original
          // structure of the code, so we just assume it's not a ref here
          // for now
          return raw
        } else {
          return `${context.helperString(UNREF)}(${raw})`
        }
      } else if (type === BindingTypes.PROPS) {
        // use __props which is generated by compileScript so in ts mode
        // it gets correct type
        return `__props.${raw}`
      } else if (type === BindingTypes.PROPS_ALIASED) {
        // prop with a different local alias (from defineProps() destructure)
        return `__props.${bindingMetadata.__propsAliases[raw]}`
      }
    } else {
      if (type && type.startsWith('setup')) {
        // setup bindings in non-inline mode
        return `$setup.${raw}`
      } else if (type === BindingTypes.PROPS_ALIASED) {
        return `$props.${bindingMetadata.__propsAliases[raw]}`
      } else if (type) {
        return `$${type}.${raw}`
      }
    }

    // fallback to ctx
    return `_ctx.${raw}`
  }

  // fast path if expression is a simple identifier.
  const rawExp = node.content
  // bail constant on parens (function invocation) and dot (member access)
  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0

  if (isSimpleIdentifier(rawExp)) {
    const isScopeVarReference = context.identifiers[rawExp]
    const isAllowedGlobal = isGloballyWhitelisted(rawExp)
    const isLiteral = isLiteralWhitelisted(rawExp)
    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {
      // const bindings exposed from setup can be skipped for patching but
      // cannot be hoisted to module scope
      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {
        node.constType = ConstantTypes.CAN_SKIP_PATCH
      }
      node.content = rewriteIdentifier(rawExp)
    } else if (!isScopeVarReference) {
      if (isLiteral) {
        node.constType = ConstantTypes.CAN_STRINGIFY
      } else {
        node.constType = ConstantTypes.CAN_HOIST
      }
    }
    return node
  }

  let ast
  // exp needs to be parsed differently:
  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw
  //    exp, but make sure to pad with spaces for consistent ranges
  // 2. Expressions: wrap with parens (for e.g. object expressions)
  // 3. Function arguments (v-for, v-slot): place in a function argument position
  const source = asRawStatements
    ? ` ${rawExp} `
    : `(${rawExp})${asParams ? `=>{}` : ``}`
  try {
    ast = babelParser.parse(source, {
      plugins: context.expressionPlugins
    }).program
  } catch (e) {
    return node
  }

  const ids= []
  const parentStack = []
  const knownIds = Object.create(context.identifiers)

  walkIdentifiers(
    ast,
    (node, parent, _, isReferenced, isLocal) => {
      if (isStaticPropertyKey(node, parent)) {
        return
      }

      const needPrefix = isReferenced && canPrefix(node)
      if (needPrefix && !isLocal) {
        if (isStaticProperty(parent) && parent.shorthand) {
          // property shorthand like { foo }, we need to add the key since
          // we rewrite the value
          node.prefix = `${node.name}: `
        }
        node.name = rewriteIdentifier(node.name, parent, node)
        ids.push(node)
      } else {
        // The identifier is considered constant unless it's pointing to a
        // local scope variable (a v-for alias, or a v-slot prop)
        if (!(needPrefix && isLocal) && !bailConstant) {
          node.isConstant = true
        }
        // also generate sub-expressions for other identifiers for better
        // source map support. (except for property keys which are static)
        ids.push(node)
      }
    },
    true, // invoke on ALL identifiers
    parentStack,
    knownIds
  )

  // We break up the compound expression into an array of strings and sub
  // expressions (for identifiers that have been prefixed). In codegen, if
  // an ExpressionNode has the `.children` property, it will be used instead of
  // `.content`.
  const children = []
  ids.sort((a, b) => a.start - b.start)
  ids.forEach((id, i) => {
    // range is offset by -1 due to the wrapping parens when parsed
    const start = id.start - 1
    const end = id.end - 1
    const last = ids[i - 1]
    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)
    if (leadingText.length || id.prefix) {
      children.push(leadingText + (id.prefix || ``))
    }
    const source = rawExp.slice(start, end)
    children.push(
      createSimpleExpression(
        id.name,
        false,
        {
          source,
          start: advancePositionWithClone(node.loc.start, source, start),
          end: advancePositionWithClone(node.loc.start, source, end)
        },
        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT
      )
    )
    if (i === ids.length - 1 && end < rawExp.length) {
      children.push(rawExp.slice(end))
    }
  })

  let ret
  if (children.length) {
    ret = createCompoundExpression(children, node.loc)
  } else {
    ret = node
    ret.constType = bailConstant
      ? ConstantTypes.NOT_CONSTANT
      : ConstantTypes.CAN_STRINGIFY
  }
  ret.identifiers = Object.keys(knownIds)
  return ret
}

function canPrefix(id) {
  // skip whitelisted globals
  if (isGloballyWhitelisted(id.name)) {
    return false
  }
  // special case for webpack compilation
  if (id.name === 'require') {
    return false
  }
  return true
}

function stringifyExpression(exp){
  if (isString(exp)) {
    return exp
  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return exp.content
  } else {
    return exp.children.map(stringifyExpression).join('')
  }
}

#+end_src
**** getParentCondition()

#+name: getParentCondition
#+begin_src js -n -r
function getParentCondition(node) {
  while (true) {
    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {
      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {
        node = node.alternate
      } else {
        return node
      }
    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {
      node = node.value
    }
  }
}

#+end_src
**** createIfBranch()

#+name: createIfBranch
#+begin_src js -n -r
function createIfBranch(node, dir) {
  return {
    type: NodeTypes.IF_BRANCH,
    loc: node.loc,
    condition: dir.name === 'else' ? undefined : dir.exp,
    children:
      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')
        ? node.children
        : [node],
    userKey: findProp(node, `key`)
  }
}
#+end_src
**** createCodegenNodeForBranch()

#+name: createCodegenNodeForBranch
#+begin_src js -n -r
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // 这里是考虑到只有 v-if 的情况，因为 v-if 指令最后都会被解析成三目运算符形式
      // 如： <div v-if="foo"/><div v-else/> => foo ? ... : ...
      // 如： <div v-if="foo"/><div v-else-if="bar"/><div v-else/> => foo ? ... : bar ? ... : ...
      // 所以必需得要有一个 v-else，如果没有的话就相当于是 `foo ? ...` 这样的语句是不合法的
      // 因此这里在判断没有 v-else 分支的情况时默认给它创建了个注释节点
      createCallExpression(context.helper(CREATE_COMMENT), [
        __DEV__ ? '"v-if"' : '""',
        'true'
      ])
    )
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context)
  }
}
#+end_src
**** createChildrenCodegenNode()

#+name: createChildrenCodegenNode
#+begin_src js -n -r
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      ConstantTypes.CAN_HOIST
    )
  )
  const { children } = branch
  const firstChild = children[0]
  const needFragmentWrapper =
    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {
      // optimize away nested fragments when child is a ForNode
      const vnodeCall = firstChild.codegenNode
      injectProp(vnodeCall, keyProperty, context)
      return vnodeCall
    } else {
      let patchFlag = PatchFlags.STABLE_FRAGMENT
      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]

      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),
        undefined,
        undefined,
        true,
        false,
        false /* isComponent */,
        branch.loc
      )
    }
  } else {
    const ret = firstChild.codegenNode
    const vnodeCall = getMemoedVNodeCall(ret)
    // Change createVNode to createBlock.
    if (vnodeCall.type === NodeTypes.VNODE_CALL) {
      makeBlock(vnodeCall, context)
    }
    // inject branch key
    injectProp(vnodeCall, keyProperty, context)
    return ret
  }
}
#+end_src

**** isSameKey()

#+name: isSameKey
#+begin_src js -n -r
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false
  }
  if (a.type === NodeTypes.ATTRIBUTE) {
    if (a.value.content !== b.value.content) {
      return false
    }
  } else {
    // directive
    const exp = a.exp
    const branchExp = b.exp
    if (exp.type !== branchExp.type) {
      return false
    }
    if (
      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||
      exp.isStatic !== branchExp.isStatic ||
      exp.content !== branchExp.content
    ) {
      return false
    }
  }
  return true
}
#+end_src

*** transformSlotOutlet()

处理 ~<slot/>~ 插槽,插槽会被解析并存放到 ~$slots~ 上，实际渲染是调用 ~renderSlot~ 这个
函数(~renderSlot($slots, slotName, props, children, scopeId~), 而每个 slot 都是个
函数，例如使用 ~h~ 函数是(~h(Comp, props, { default: () => default slot, slot1: ()
=> named slot })~, 因为 ~Comp~ 是组件类型，因此第三个参数会被当前 slots 处理，详情
[[https://www.cheng92.com/vue/vue-mind-map-runtime-core-1/#h-function][Vue3 源码头脑风暴之 7 ☞ runtime-core(1) - 若叶知秋]])。

#+name: transformSlotOutlet
#+begin_src js -n -r
const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) { // <slot/>
    const { children, loc } = node
    const { slotName, slotProps } = processSlotOutlet(node, context)

    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      '{}', //  props
      'undefined', // children
      'true'
    ]
    let expectedLen = 2

    if (slotProps) {
      slotArgs[2] = slotProps
      expectedLen = 3
    }

    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc)
      expectedLen = 4
    }

    if (context.scopeId && !context.slotted) { (ref:transformSlotOutlet-if-slotted)
      expectedLen = 5
    }
    slotArgs.splice(expectedLen) // remove unused arguments

    // -> renderSlot($slots, slotName, props, children, true)
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT), // renderSlot
      slotArgs,
      loc
    )
  }
}

function processSlotOutlet(
  node,
  context
) {
  let slotName = `"default"`
  let slotProps = undefined

  const nonNameProps = [] // 无名插槽
  logg(`processSlotOutlet| props.length = ${node.props.length}`)
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i]
    logg(`processSlotOutlet| props[${i}]`, p)
    if (p.type === NodeTypes.ATTRIBUTE) { // 静态 <slot name="xxx"/>
      if (p.value) {
        if (p.name === 'name') {
          slotName = JSON.stringify(p.value.content)
        } else {
          p.name = camelize(p.name)
          nonNameProps.push(p)
        }
      }
    } else { // 动态 <slot :name="xxx"/>
      // 动态插槽 <slot v-bind:name="slotName"/>
      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
        if (p.exp) slotName = p.exp
      } else {
        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content)
        }
        nonNameProps.push(p)
      }
    }
  }

  logg(`processSlotOutlet| nonNameProps.length=${nonNameProps.length}`)
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(node, context, nonNameProps)
    slotProps = props

    if (directives.length) {
      logg('[ERROR] X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET')
    }
  }

  return {
    slotName,
    slotProps
  }
}
#+end_src

red:Testing

#+html: <br>
#+begin_details Testing v-if with slot :title-color red

#+name: transform-testing-v-if-slot
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const { node, root } = parseWithIfTransform("<template v-if='ok'><slot/></template>")
logg('root ast', root)
logg(`node.type=${node.type}, NodeTypes.IF=${NodeTypes.IF}`)
logg(`node.codegenNode`, node.codegenNode)
logg(`node.codegenNode.consequent`, node.codegenNode.consequent)
#+end_src
#+end_details

#+html: <br>
#+begin_details Testing default slot outlet :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots("<slot/>")
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode', ast.children[0].codegenNode)
#+end_src

~type:14~ 是函数调用 => ~renderSlot($slots, 'default')~
#+end_details

#+html: <br>
#+begin_details Testing named slot outlet :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots("<slot name="foo" />")
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode - 具名插槽', ast.children[0].codegenNode)
#+end_src

~type:14~ 是函数调用 => ~renderSlot($slots, "foo")~
#+end_details

#+html: <br>
#+begin_details Testing dynamic named slot outlet :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots("<slot :name="foo" />")
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode - 具名插槽', ast.children[0].codegenNode)
#+end_src

~type:14~ 是函数调用 => ~renderSlot($slots, foo)~
#+end_details

#+html: <br>
#+begin_details Testing dynamic named slot outlet with prefixIdentifiers=true :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots("<slot :name="foo" />", { prefixIdentifiers: true })
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode - 具名插槽', ast.children[0].codegenNode)
#+end_src

~type:14~ 是函数调用 => ~renderSlot(_ctx.$slots, _ctx.foo)~ 且变量都使用上下文对象引
用。
#+end_details

#+html: <br>
#+begin_details Testing default slot outlet with props :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots(
  `<slot :name="foo" foo="bar" :bax="qux" :foo-bar="foo-bar" />`
)
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode - 具名插槽', ast.children[0].codegenNode)
logg('ast.children[0].codegenNode.arguments', ast.children[0].codegenNode.arguments')
#+end_src

~type:14~ 是函数调用 => ~renderSlot($slots, "foo", { foo, bax, fooBar })~ 。
#+end_details

#+html: <br>
#+begin_details Testing default slot outlet with fallback :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots(
  `<slot :name="foo" foo="bar" :bax="qux" :foo-bar="foo-bar"><div/></slot>`
)
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode.arguments', ast.children[0].codegenNode.arguments')
logg('ast.children[0].codegenNode.arguments[3]', ast.children[0].codegenNode.arguments[3')
#+end_src

~type:14~ 是函数调用 => ~renderSlot($slots, "foo", {}, () => div)~ 第四个是
~children~ 如果指定了 ~{slotted: false}~ 那这个 ~children~ 就一直是 ~undefined~ 如下面的
示例。
#+end_details

#+html: <br>
#+begin_details Testing default slot outlet with slotted=false :title-color red

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>
const ast = parseWithSlots(
  `<slot><div/></slot>`,
  { slotted: false, scopeId: 'foo' }
)
logg('ast.children[0]', ast.children[0])
logg('ast.children[0].codegenNode.arguments', ast.children[0].codegenNode.arguments)
logg(`ast.children[0].codegenNode.arguments[3]=${ast.children[0].codegenNode.arguments[3]}`)
#+end_src

#+RESULTS:
#+begin_example
--------- createStructuralDirectiveTransform ---------
name=/^(if|else|else-if)$/, matches=(n) => name.test(n)
--------- traverseNode ---------
{
  type: 0,
  children: [
    {
      type: 1,
      ns: 0,
      tag: 'slot',
      tagType: 2,
      props: [],
      isSelfClosing: false,
      children: [Array],
      loc: [Object],
      codegenNode: undefined
    }
  ],
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 20, line: 1, offset: 19 },
    source: '<slot><div/></slot>'
  }
}
--------- traverseNode ---------
{
  type: 1,
  ns: 0,
  tag: 'slot',
  tagType: 2,
  props: [],
  isSelfClosing: false,
  children: [
    {
      type: 1,
      ns: 0,
      tag: 'div',
      tagType: 0,
      props: [],
      isSelfClosing: true,
      children: [],
      loc: [Object],
      codegenNode: undefined
    }
  ],
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 20, line: 1, offset: 19 },
    source: '<slot><div/></slot>'
  },
  codegenNode: undefined
}
--------- processSlotOutlet| props.length = 0 ---------
--------- processSlotOutlet| nonNameProps.length=0 ---------
--------- traverseNode ---------
{
  type: 1,
  ns: 0,
  tag: 'div',
  tagType: 0,
  props: [],
  isSelfClosing: true,
  children: [],
  loc: {
    start: { column: 7, line: 1, offset: 6 },
    end: { column: 13, line: 1, offset: 12 },
    source: '<div/>'
  },
  codegenNode: undefined
}
--------- createRootCodegen ---------
children=1, 只有一个用 block, 多个用Fragment
--------- ast.children[0] ---------
{
  type: 1,
  ns: 0,
  tag: 'slot',
  tagType: 2,
  props: [],
  isSelfClosing: false,
  children: [
    {
      type: 1,
      ns: 0,
      tag: 'div',
      tagType: 0,
      props: [],
      isSelfClosing: true,
      children: [],
      loc: [Object],
      codegenNode: [Object]
    }
  ],
  loc: {
    start: { column: 1, line: 1, offset: 0 },
    end: { column: 20, line: 1, offset: 19 },
    source: '<slot><div/></slot>'
  },
  codegenNode: {
    type: 14,
    loc: { start: [Object], end: [Object], source: '<slot><div/></slot>' },
    callee: Symbol(renderSlot),
    arguments: [ '$slots', '"default"', '{}', [Object], 'true' ]
  }
}
--------- ast.children[0].codegenNode.arguments ---------
[
  '$slots',
  '"default"',
  '{}',
  {
    type: 18,
    params: [],
    returns: [ [Object] ],
    newline: false,
    isSlot: false,
    loc: { start: [Object], end: [Object], source: '<slot><div/></slot>' }
  },
  'true'
]
--------- ast.children[0].codegenNode.arguments[3]=[object Object] ---------
undefined
#+end_example

~type:14~ 是函数调用 => ~renderSlot($slots, "foo", {}, undefined)~ 第四个是
~children~ 是 undefined 因为 ~slotted:false~ 在[[(transformSlotOutlet-if-slotted)][这里]]拦截了 children 的处理。
#+end_details
*** transformExpression()

#+name: transformExpression
#+begin_src js -n -r
const isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')

const transformExpression = (node, context) => {
  logg(`transformExpression`, node)
  // 插值处理
  if (node.type === NodeTypes.INTERPOLATION) {
    node.content = processExpression(
      node.content ,
      context
    )
  } else if (node.type === NodeTypes.ELEMENT) {
    // 处理元素上的指令
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i]
      logg(`transformExpression - prop[${i}] - directive`, node.props[i])
      // do not process for v-on & v-for since they are special handled
      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') { // v-for 在 vFor.ts 中处理
        const exp = dir.exp
        const arg = dir.arg
        // do not process exp if this is v-on:arg - we need special handling
        // for wrapping inline statements.
        if (
          exp &&
          exp.type === NodeTypes.SIMPLE_EXPRESSION &&
          !(dir.name === 'on' && arg)
        ) {
          dir.exp = processExpression(
            exp,
            context,
            // slot args must be processed as function params
            dir.name === 'slot'
          )
        }
        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {
          dir.arg = processExpression(arg, context)
        }
      }
    }
  }
}

// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !__BROWSER__ check so that it can be
// tree-shaken from the browser build.
function processExpression(
  node,
  context,
  // some expressions like v-slot props & v-for aliases should be parsed as
  // function params
  asParams = false,
  // v-on handler values may contain multiple statements
  asRawStatements = false,
  localVars = Object.create(context.identifiers)
) {
  if (__BROWSER__) {
    return node
  }

  if (!context.prefixIdentifiers || !node.content.trim()) {
    return node
  }

  const { inline, bindingMetadata } = context
  const rewriteIdentifier = (raw, parent, id) => {
    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]
    if (inline) {
      // x = y
      const isAssignmentLVal =
        parent && parent.type === 'AssignmentExpression' && parent.left === id
      // x++
      const isUpdateArg =
        parent && parent.type === 'UpdateExpression' && parent.argument === id
      // ({ x } = y)
      const isDestructureAssignment =
        parent && isInDestructureAssignment(parent, parentStack)

      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {
        return raw
      } else if (type === BindingTypes.SETUP_REF) {
        return `${raw}.value`
      } else if (type === BindingTypes.SETUP_MAYBE_REF) {
        // const binding that may or may not be ref
        // if it's not a ref, then assignments don't make sense -
        // so we ignore the non-ref assignment case and generate code
        // that assumes the value to be a ref for more efficiency
        return isAssignmentLVal || isUpdateArg || isDestructureAssignment
          ? `${raw}.value`
          : `${context.helperString(UNREF)}(${raw})`
      } else if (type === BindingTypes.SETUP_LET) {
        if (isAssignmentLVal) {
          // let binding.
          // this is a bit more tricky as we need to cover the case where
          // let is a local non-ref value, and we need to replicate the
          // right hand side value.
          // x = y --> isRef(x) ? x.value = y : x = y
          const { right: rVal, operator } = parent
          const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1)
          const rExpString = stringifyExpression(
            processExpression(
              createSimpleExpression(rExp, false),
              context,
              false,
              false,
              knownIds
            )
          )
          return `${context.helperString(IS_REF)}(${raw})${``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`
        } else if (isUpdateArg) {
          // make id replace parent in the code range so the raw update operator
          // is removed
          id.start = parent.start
          id.end = parent.end
          const { prefix: isPrefix, operator } = parent
          const prefix = isPrefix ? operator : ``
          const postfix = isPrefix ? `` : operator
          // let binding.
          // x++ --> isRef(a) ? a.value++ : a++
          return `${context.helperString(IS_REF)}(${raw})${``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`
        } else if (isDestructureAssignment) {
          // TODO
          // let binding in a destructure assignment - it's very tricky to
          // handle both possible cases here without altering the original
          // structure of the code, so we just assume it's not a ref here
          // for now
          return raw
        } else {
          return `${context.helperString(UNREF)}(${raw})`
        }
      } else if (type === BindingTypes.PROPS) {
        // use __props which is generated by compileScript so in ts mode
        // it gets correct type
        return `__props.${raw}`
      } else if (type === BindingTypes.PROPS_ALIASED) {
        // prop with a different local alias (from defineProps() destructure)
        return `__props.${bindingMetadata.__propsAliases[raw]}`
      }
    } else {
      if (type && type.startsWith('setup')) {
        // setup bindings in non-inline mode
        return `$setup.${raw}`
      } else if (type === BindingTypes.PROPS_ALIASED) {
        return `$props.${bindingMetadata.__propsAliases[raw]}`
      } else if (type) {
        return `$${type}.${raw}`
      }
    }

    // fallback to ctx
    return `_ctx.${raw}`
  }

  // fast path if expression is a simple identifier.
  const rawExp = node.content
  // bail constant on parens (function invocation) and dot (member access)
  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0

  logg(`processExpression - node.content: ${rawExp}`)
  if (isSimpleIdentifier(rawExp)) {
    const isScopeVarReference = context.identifiers[rawExp]
    const isAllowedGlobal = isGloballyWhitelisted(rawExp)
    const isLiteral = isLiteralWhitelisted(rawExp)
    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {
      // const bindings exposed from setup can be skipped for patching but
      // cannot be hoisted to module scope
      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {
        node.constType = ConstantTypes.CAN_SKIP_PATCH
      }
      node.content = rewriteIdentifier(rawExp)
    } else if (!isScopeVarReference) {
      if (isLiteral) {
        node.constType = ConstantTypes.CAN_STRINGIFY
      } else {
        node.constType = ConstantTypes.CAN_HOIST
      }
    }
    return node
  }

  let ast
  // exp needs to be parsed differently:
  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw
  //    exp, but make sure to pad with spaces for consistent ranges
  // 2. Expressions: wrap with parens (for e.g. object expressions)
  // 3. Function arguments (v-for, v-slot): place in a function argument position
  const source = asRawStatements
    ? ` ${rawExp} `
    : `(${rawExp})${asParams ? `=>{}` : ``}`
  try {
    ast = babelParser.parse(source, {
      plugins: context.expressionPlugins
    }).program
  } catch (e) {
    return node
  }

  logg(`processExpression - babel parse`, ast)
  const ids = []
  const parentStack = []
  const knownIds = Object.create(context.identifiers)

  walkIdentifiers(
    ast,
    (node, parent, _, isReferenced, isLocal) => {
      if (isStaticPropertyKey(node, parent)) {
        return
      }

      const needPrefix = isReferenced && canPrefix(node)
      if (needPrefix && !isLocal) {
        if (isStaticProperty(parent) && parent.shorthand) {
          // property shorthand like { foo }, we need to add the key since
          // we rewrite the value
          node.prefix = `${node.name}: `
        }
        node.name = rewriteIdentifier(node.name, parent, node)
        ids.push(node)
      } else {
        // The identifier is considered constant unless it's pointing to a
        // local scope variable (a v-for alias, or a v-slot prop)
        if (!(needPrefix && isLocal) && !bailConstant) {
          node.isConstant = true
        }
        // also generate sub-expressions for other identifiers for better
        // source map support. (except for property keys which are static)
        ids.push(node)
      }
    },
    true, // invoke on ALL identifiers
    parentStack,
    knownIds
  )

  // We break up the compound expression into an array of strings and sub
  // expressions (for identifiers that have been prefixed). In codegen, if
  // an ExpressionNode has the `.children` property, it will be used instead of
  // `.content`.
  const children = []
  ids.sort((a, b) => a.start - b.start)
  ids.forEach((id, i) => {
    // range is offset by -1 due to the wrapping parens when parsed
    const start = id.start - 1
    const end = id.end - 1
    const last = ids[i - 1]
    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)
    if (leadingText.length || id.prefix) {
      children.push(leadingText + (id.prefix || ``))
    }
    const source = rawExp.slice(start, end)
    children.push(
      createSimpleExpression(
        id.name,
        false,
        {
          source,
          start: advancePositionWithClone(node.loc.start, source, start),
          end: advancePositionWithClone(node.loc.start, source, end)
        },
        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT
      )
    )
    if (i === ids.length - 1 && end < rawExp.length) {
      children.push(rawExp.slice(end))
    }
  })

  let ret
  if (children.length) {
    ret = createCompoundExpression(children, node.loc)
  } else {
    ret = node
    ret.constType = bailConstant
      ? ConstantTypes.NOT_CONSTANT
      : ConstantTypes.CAN_STRINGIFY
  }
  ret.identifiers = Object.keys(knownIds)
  return ret
}

function canPrefix(id) {
  // skip whitelisted globals
  if (isGloballyWhitelisted(id.name)) {
    return false
  }
  // special case for webpack compilation
  if (id.name === 'require') {
    return false
  }
  return true
}

function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp
  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return exp.content
  } else {
    return (exp.children)
      .map(stringifyExpression)
      .join('')
  }
}

#+end_src
*** transformFor()

支持各种使用方式：

无括号： ~<div v-for="value in items" />~, ~<div v-for="value, key in items" />~, ~<div
v-for="value, key, index in items" />~

有括号： ~<div v-for="(value) in items" />~, ~<div v-for="( value, key ) in items" />~, ~<div
v-for="( value, key, index ) in items" />~

省略部分: ~<div v-for="(,key,index) in items" />~, ~<div v-for="(,,index) in items" />~, ~<div
v-for="(value,,index) in items" />~

解构： ~<div v-for="({ foo, bar }) in items" />~

#+name: transformFor
#+begin_src js -n -r
const transformFor = createStructuralDirectiveTransform(
  'for',
  (node, dir, context) => {
    const { helper, removeHelper } = context
    return processFor(node, dir, context, forNode => {
      // create the loop render function expression now, and add the
      // iterator on exit after all children have been traversed
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ])
      const isTemplate = isTemplateNode(node)
      const memo = findDir(node, 'memo')
      const keyProp = findProp(node, `key`)
      const keyExp =
        keyProp &&
        (keyProp.type === NodeTypes.ATTRIBUTE
          ? createSimpleExpression(keyProp.value.content, true)
          : keyProp.exp)
      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null

      if (!__BROWSER__ && isTemplate) {
        // #2085 / #5288 process :key and v-memo expressions need to be
        // processed on `<template v-for>`. In this case the node is discarded
        // and never traversed so its binding expressions won't be processed
        // by the normal transforms.
        if (memo) {
          memo.exp = processExpression(
            memo.exp ,
            context
          )
        }
        if (keyProperty && keyProp.type !== NodeTypes.ATTRIBUTE) {
          keyProperty.value = processExpression(
            keyProperty.value ,
            context
          )
        }
      }

      const isStableFragment =
        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&
        forNode.source.constType > ConstantTypes.NOT_CONSTANT
      const fragmentFlag = isStableFragment
        ? PatchFlags.STABLE_FRAGMENT
        : keyProp
        ? PatchFlags.KEYED_FRAGMENT
        : PatchFlags.UNKEYED_FRAGMENT

      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        undefined,
        renderExp,
        fragmentFlag +
          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),
        undefined,
        undefined,
        true /* isBlock */,
        !isStableFragment /* disableTracking */,
        false /* isComponent */,
        node.loc
      )

      return () => {
        // finish the codegen now that all children have been traversed
        let childBlock
        const { children } = forNode

        // check <template v-for> key placement
        if ((__DEV__ || !__BROWSER__) && isTemplate) {
          node.children.some(c => {
            if (c.type === NodeTypes.ELEMENT) {
              const key = findProp(c, 'key')
              if (key) {
                logg(`transformFor - key on template`)
                return true
              }
            }
          })
        }

        const needFragmentWrapper =
          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT
        const slotOutlet = isSlotOutlet(node)
          ? node
          : isTemplate &&
            node.children.length === 1 &&
            isSlotOutlet(node.children[0])
          ? node.children[0] // api-extractor somehow fails to infer this
          : null

        if (slotOutlet) {
          // <slot v-for="..."> or <template v-for="..."><slot/></template>
          childBlock = slotOutlet.codegenNode
          if (isTemplate && keyProperty) {
            // <template v-for="..." :key="..."><slot/></template>
            // we need to inject the key to the renderSlot() call.
            // the props for renderSlot is passed as the 3rd argument.
            injectProp(childBlock, keyProperty, context)
          }
        } else if (needFragmentWrapper) {
          // <template v-for="..."> with text or multi-elements
          // should generate a fragment block for each loop
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : undefined,
            node.children,
            PatchFlags.STABLE_FRAGMENT +
              (__DEV__
                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`
                : ``),
            undefined,
            undefined,
            true,
            undefined,
            false /* isComponent */
          )
        } else {
          // Normal element v-for. Directly use the child's codegenNode
          // but mark it as a block.
          childBlock = children[0].codegenNode
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context)
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              // switch from block to vnode
              removeHelper(OPEN_BLOCK)
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              )
            } else {
              // switch from vnode to block
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              )
            }
          }
          childBlock.isBlock = !isStableFragment
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK)
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))
          }
        }

        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          )
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...(keyExp ? [` && _cached.key === `, keyExp] : []),
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ])
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached++))
          )
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true /* force newline */
            )
          )
        }
      }
    })
  }
)

// target-agnostic transform used for both Client and SSR
function processFor(
  node,
  dir,
  context,
  processCodegen
) {
  if (!dir.exp) {
    logg(`processFor - dir.exp is null`)
    return
  }

  const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp,
    context
  )

  if (!parseResult) {
    logg(`processFor - parseResult is null`)
    return
  }

  const { addIdentifiers, removeIdentifiers, scopes } = context
  const { source, value, key, index } = parseResult

  const forNode = {
    type: NodeTypes.FOR,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  }

  context.replaceNode(forNode)

  // bookkeeping
  scopes.vFor++
  if (!__BROWSER__ && context.prefixIdentifiers) {
    // scope management
    // inject identifiers to context
    value && addIdentifiers(value)
    key && addIdentifiers(key)
    index && addIdentifiers(index)
  }

  const onExit = processCodegen && processCodegen(forNode)

  return () => {
    scopes.vFor--
    if (!__BROWSER__ && context.prefixIdentifiers) {
      value && removeIdentifiers(value)
      key && removeIdentifiers(key)
      index && removeIdentifiers(index)
    }
    if (onExit) onExit()
  }
}

const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/
const stripParensRE = /^\(|\)$/g

function parseForExpression(
  input,
  context
) {
  const loc = input.loc
  const exp = input.content
  const inMatch = exp.match(forAliasRE)
  if (!inMatch) return

  const [, LHS, RHS] = inMatch

  const result = {
    source: createAliasExpression(
      loc,
      RHS.trim(),
      exp.indexOf(RHS, LHS.length)
    ),
    value: undefined,
    key: undefined,
    index: undefined
  }
  if (!__BROWSER__ && context.prefixIdentifiers) {
    result.source = processExpression(
      result.source,
      context
    )
  }

  let valueContent = LHS.trim().replace(stripParensRE, '').trim()
  const trimmedOffset = LHS.indexOf(valueContent)

  const iteratorMatch = valueContent.match(forIteratorRE)
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, '').trim()

    const keyContent = iteratorMatch[1].trim()
    let keyOffset
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)
      result.key = createAliasExpression(loc, keyContent, keyOffset)
      if (!__BROWSER__ && context.prefixIdentifiers) {
        result.key = processExpression(result.key, context, true)
      }
    }

    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim()

      if (indexContent) {
        result.index = createAliasExpression(
          loc,
          indexContent,
          exp.indexOf(
            indexContent,
            result.key
              ? keyOffset + keyContent.length
              : trimmedOffset + valueContent.length
          )
        )
        if (!__BROWSER__ && context.prefixIdentifiers) {
          result.index = processExpression(result.index, context, true)
        }
      }
    }
  }

  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset)
    if (!__BROWSER__ && context.prefixIdentifiers) {
      result.value = processExpression(result.value, context, true)
    }
  }

  return result
}

function createAliasExpression(
  range,
  content,
  offset
) {
  return createSimpleExpression(
    content,
    false,
    getInnerRange(range, offset, content.length)
  )
}

function createForLoopParams(
  { value, key, index },
  memoArgs = []
) {
  return createParamsList([value, key, index, ...memoArgs])
}

function createParamsList(args) {
  let i = args.length
  while (i--) {
    if (args[i]) break
  }
  return args
    .slice(0, i + 1)
    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))
}
#+end_src

red:Testing

#+html: <br>
#+begin_details number expression :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="index in 5" />`)
logOn()
logg('node', node.codegenNode.children)
#+end_src
#+end_details

#+html: <br>
#+begin_details value :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="( value ) in items" />`)
logOn()
logg('node', node.codegenNode.children)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details de-structured :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="({ id, value }) in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details array de-structured value :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="([ id, value ]) in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details value and key :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="(item, key) in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details value, key and index :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="(item, key, index) in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
logg('node - source', node.source)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details skipped value and key :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="(,,index) in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
logg('node - source', node.source)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details unbracketed value :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="item in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
logg('node - source', node.source)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details unbracketed value and key :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="item, key in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
logg('node - source', node.source)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details unbracketed value, key and index :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="item, key, index in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
logg('node - source', node.source)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details unbracketed skipped key :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`<span v-for="item, , index in items" />`)
logOn()
logg('node - keyAlias', node.keyAlias)
logg('node - valueAlias', node.valueAlias)
logg('node - objectIndexAlias', node.objectIndexAlias)
logg('node - source', node.source)
node.codegenNode.children.arguments.forEach(( arg, i ) => {
  logg(`argument[${i}]`, arg)
})
#+end_src
#+end_details

#+html: <br>
#+begin_details nested v-for :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`
<div v-for="i in list"><div v-for="i in list">{{ i + j }}</div>{{ i }}</div>
`.trim(), { prefixIdentifiers: true })
logOn()
const outerDiv = node.children[0]
const outerExp = outerDiv.children[1]
const innerFor = outerDiv.children[0]
const innerExp = innerFor.children[0].children[0]
logg("innerFor", innerFor)
logg(`innerExp.content`, innerExp.content)
logg(`outerExp.content`, outerExp.content)
#+end_src
#+end_details

#+html: <br>
#+begin_details complex expressions :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const { node } = parseWithForTransform(`
<div v-for="({ foo = bar, baz: [qux = quux] }) in list">{{ foo + bar + baz + qux + quux }}</div>`, { prefixIdentifiers: true })
logOn()
logg('node.valueAlias', node.valueAlias)
logg('node.children[0].children[0].content', node.children[0].children[0].content)
#+end_src
#+end_details

*** transformBind

#+name: transformBind
#+begin_src js -n -r
// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, _node, context) => {
  const { exp, modifiers, loc } = dir
  const arg = dir.arg

  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {
    arg.children.unshift(`(`)
    arg.children.push(`) || ""`)
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`
  }

  // .sync is replaced by v-model:arg
  if (modifiers.includes('camel')) {
    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
      if (arg.isStatic) {
        arg.content = camelize(arg.content)
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)
      arg.children.push(`)`)
    }
  }

  if (!context.inSSR) {
    if (modifiers.includes('prop')) {
      injectPrefix(arg, '.')
    }
    if (modifiers.includes('attr')) {
      injectPrefix(arg, '^')
    }
  }

  if (
    !exp ||
    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())
  ) {
    logg(`transformBind v-bind no expression`)
    return {
      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
    }
  }

  return {
    props: [createObjectProperty(arg, exp)]
  }
}

const injectPrefix = (arg, prefix) => {
  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`)
    arg.children.push(`)`)
  }
}

#+end_src

red:Testing

#+html: <br>
#+begin_details v-bind :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

const node = parseWithVBind(`<div v-bind:id="id">`)
const props = node.codegenNode.props
logg('props', props.properties[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details dynamic arg :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logTraverseOff()
const node = parseWithVBind(`<div v-bind:[id]="id">`)
const props = node.codegenNode.props
logg('props', props)
logg('props.arguments', props.arguments)
logg('props.arguments[0].properties', props.arguments[0].properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details dynamic+modifier :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logTraverseOff()
const node = parseWithVBind(`<div v-bind:[foo(bar)].camel="id">`)
const props = node.codegenNode.props
logg('props', props)
logg('props.arguments', props.arguments)
logg('props.arguments[0].properties', props.arguments[0].properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details .prop modifier :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logTraverseOff()
const node = parseWithVBind(`<div v-bind:fooBar.prop="id">`)
const props = node.codegenNode.props
logg('props.properties[0]', props.properties[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details .prop modifier + dynamic arg :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logTraverseOff()
const node = parseWithVBind(`<div v-bind:[fooBar].prop="id">`)
const props = node.codegenNode.props
logg('props.arguments[0].properties[0]', props.arguments[0].properties[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details .prop shorthand :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logTraverseOff()
const node = parseWithVBind(`<div .fooBar="id">`)
const props = node.codegenNode.props
logg('props.properties[0]', props.properties[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details .attr :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logTraverseOff()
const node = parseWithVBind(`<div v-bind:foo-bar.attr="id">`)
const props = node.codegenNode.props
logg('props.properties[0]', props.properties[0])
#+end_src
#+end_details

*** transformModel

#+name: transformModel
#+begin_src js -n -r
const transformModel = (dir, node, context) => {
  const { exp, arg } = dir
  if (!exp) {
    logg(`transformModel no exp`)
    return createTransformProps()
  }

  const rawExp = exp.loc.source
  const expString =
    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp

  // im SFC <script setup> inline mode, the exp may have been transformed into
  // _unref(exp)
  const bindingType = context.bindingMetadata[rawExp]
  const maybeRef =
    !__BROWSER__ &&
    context.inline &&
    bindingType &&
    bindingType !== BindingTypes.SETUP_CONST

  if (
    !expString.trim() ||
    (!isMemberExpression(expString, context) && !maybeRef)
  ) {
    return createTransformProps()
  }

  if (
    !__BROWSER__ &&
    context.prefixIdentifiers &&
    isSimpleIdentifier(expString) &&
    context.identifiers[expString]
  ) {
    return createTransformProps()
  }

  const propName = arg ? arg : createSimpleExpression('modelValue', true)
  const eventName = arg
    ? isStaticExp(arg)
      ? `onUpdate:${arg.content}`
      : createCompoundExpression(['"onUpdate:" + ', arg])
    : `onUpdate:modelValue`

  let assignmentExp
  const eventArg = context.isTS ? `($event: any)` : `$event`
  if (maybeRef) {
    if (bindingType === BindingTypes.SETUP_REF) {
      // v-model used on known ref.
      assignmentExp = createCompoundExpression([
        `${eventArg} => ((`,
        createSimpleExpression(rawExp, false, exp.loc),
        `).value = $event)`
      ])
    } else {
      // v-model used on a potentially ref binding in <script setup> inline mode.
      // the assignment needs to check whether the binding is actually a ref.
      const altAssignment =
        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`
      assignmentExp = createCompoundExpression([
        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
        createSimpleExpression(rawExp, false, exp.loc),
        `).value = $event : ${altAssignment})`
      ])
    }
  } else {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ])
  }

  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ]

  // cache v-model handler if applicable (when it doesn't refer any scope vars)
  if (
    !__BROWSER__ &&
    context.prefixIdentifiers &&
    !context.inVOnce &&
    context.cacheHandlers &&
    !hasScopeRef(exp, context.identifiers)
  ) {
    props[1].value = context.cache(props[1].value)
  }

  // modelModifiers: { foo: true, "bar-baz": true }
  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {
    const modifiers = dir.modifiers
      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
      .join(`, `)
    const modifiersKey = arg
      ? isStaticExp(arg)
        ? `${arg.content}Modifiers`
        : createCompoundExpression([arg, ' + "Modifiers"'])
      : `modelModifiers`
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          ConstantTypes.CAN_HOIST
        )
      )
    )
  }

  return createTransformProps(props)
}

function createTransformProps(props = []) {
  return { props }
}
#+end_src

red:Testing

#+html: <br>
#+begin_details v-model :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<input v-model="model" />`)
const node = root.children[0]
const props = node.codegenNode.props.properties
logOn()
logg("node", node)
logg('props', props)
#+end_src
#+end_details

#+html: <br>
#+begin_details compound expression :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<input v-model="model[index]" />`)
const node = root.children[0]
const props = node.codegenNode.props.properties
logOn()
logg("node", node)
logg('props', props)
#+end_src
#+end_details

#+html: <br>
#+begin_details with argument :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<input v-model:value="model[index]" />`)
const node = root.children[0]
const props = node.codegenNode.props.properties
logOn()
logg("node", node)
logg('props', props)
#+end_src
#+end_details

#+html: <br>
#+begin_details with dynamic argument :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<input v-model:[value]="model[index]" />`)
const node = root.children[0]
const props = node.codegenNode.props.properties
logOn()
logg("node", node)
logg('props', props)
#+end_src
#+end_details

#+html: <br>
#+begin_details cache update handler :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<input v-model="foo" />`, {
  prefixIdentifiers: true,
  cacheHandlers: true
})
const node = root.children[0]
const props = node.codegenNode.props.properties
logOn()
logg(`root.cached=${root.cached}`)
const codegen = node.codegenNode
logg("node.codegenNode", codegen)
logg('codegenNode.dynamicProps', codegen.dynamicProps)
logg(`codegen.props.properties`, codegen.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details not cache update handler if it refers v-for scope vairables :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<input v-for="i in list" v-model="foo[i]" />`, {
  prefixIdentifiers: true,
  cacheHandlers: true
})
const node = root.children[0]
logOn()
logg(`root.cached=${root.cached}`)
const codegen = node.children[0].codegenNode
logg("node.codegenNode", codegen)
logg('codegenNode.dynamicProps', codegen.dynamicProps)
logg(`codegen.props.properties`, codegen.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details not cache update handler if it inside v-once :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<div v-once><input v-model="foo" /></div>`, {
  prefixIdentifiers: true,
  cacheHandlers: true
})
const node = root.children[0]
logOn()
logg(`root.cached=${root.cached}`)
#+end_src

#+end_details

#+html: <br>
#+begin_details mark update handler dynamic if it refers slot scope variables :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<Comp v-slot="{foo}"><input v-model="foo.bar" /></Comp>`, {
  prefixIdentifiers: true,
})
const node = root.children[0]
logOn()
const codegen = node.children[0].codegenNode
logg("codegenNode.dynamicProps", codegenNode.dynamicProps)
#+end_src
#+end_details


#+html: <br>
#+begin_details should generate modelModifiers for component v-model :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<Comp v-model.trim.bar-baz="foo" />`, {
  prefixIdentifiers: true,
})
const node = root.children[0]
logOn()
logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
logg("node.codegenNode.dynamicProps", node.codegenNode.dynamicProps)
#+end_src
#+end_details

#+html: <br>
#+begin_details should generate modelModifiers for component v-model with arguments :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const root = parseWithVModel(`<Comp v-model:foo.trim="foo"  v-model:bar.number="bar" />`, {
  prefixIdentifiers: true,
})
const node = root.children[0]
logOn()
logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
logg("node.codegenNode.dynamicProps", node.codegenNode.dynamicProps)
#+end_src
#+end_details

*** transformOn()

v-on 表达式正则(~/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/~)：

#+begin_export html
<a href="../assets/img/vue3plus/d/v-on-exp-handler-re.svg"
data-fancybox="gallery"
data-caption="Preview"
><img src="../assets/img/vue3plus/d/v-on-exp-handler-re.svg"/></a>
#+end_export

#+name: transformOn
#+begin_src js -n -r
// 函数表达式正则, @click="fnExp"
const fnExpRE =
  /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/

const transformOn = (
  dir,
  node,
  context,
  augmentor
) => {
  const { loc, modifiers, arg } = dir

  let eventName
  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
    if (arg.isStatic) {
      let rawName = arg.content

      // 将事件名转成驼峰式
      eventName = createSimpleExpression(
        toHandlerKey(camelize(rawName)),
        true,
        arg.loc
      )
    } else {
      // #2388 toHandlerKey 将事件名转成 onXxx, 如：eventName -> onEventName
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ])
    }
  } else {
    // already a compound expression.

    eventName = arg
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)
    eventName.children.push(`)`)
  }

  // handler processing, 事件表达式内容
  let exp = dir.exp
  if (exp && !exp.content.trim()) {
    exp = undefined
  }
  // 事件处理函数缓存
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content, context)
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))
    const hasMultipleStatements = exp.content.includes(`;`)

    // process the expression since it's been skipped
    if (!__BROWSER__ && context.prefixIdentifiers) {
      isInlineStatement && context.addIdentifiers(`$event`)
      exp = dir.exp = processExpression(
        exp,
        context,
        false,
        hasMultipleStatements
      )
      isInlineStatement && context.removeIdentifiers(`$event`)
      // with scope analysis, the function is hoistable if it has no reference
      // to scope variables.
      shouldCache =
        context.cacheHandlers &&
        // unnecessary to cache inside v-once
        !context.inVOnce &&
        // runtime constants don't need to be cached
        // (this is analyzed by compileScript in SFC <script setup>)
        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&
        // #1541 bail if this is a member exp handler passed to a component -
        // we need to use the original function to preserve arity,
        // e.g. <transition> relies on checking cb.length to determine
        // transition end handling. Inline function is ok since its arity
        // is preserved even when cached.
        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&
        // bail if the function references closure variables (v-for, v-slot)
        // it must be passed fresh to avoid stale values.
        !hasScopeRef(exp, context.identifiers)
      // If the expression is optimizable and is a member expression pointing
      // to a function, turn it into invocation (and wrap in an arrow function
      // below) so that it always accesses the latest value when called - thus
      // avoiding the need to be patched.
      if (shouldCache && isMemberExp) {
        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
          exp.content = `${exp.content} && ${exp.content}(...args)`
        } else {
          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]
        }
      }
    }

    if (isInlineStatement || (shouldCache && isMemberExp)) {
      // wrap inline statement in a function expression
      // ($event) => statement
      // (...args) => { statement1;statement2 }
      exp = createCompoundExpression([
        `${
          isInlineStatement
            ? `$event`
            : `(...args)`
        } => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ])
    }
  }

  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  }

  // apply extended compiler augmentor
  if (augmentor) {
    ret = augmentor(ret)
  }

  if (shouldCache) {
    // cache handlers so that it's always the same handler being passed down.
    // this avoids unnecessary re-renders when users use inline handlers on
    // components.
    ret.props[0].value = context.cache(ret.props[0].value)
  }

  // mark the key as handler for props normalization check
  ret.props.forEach(p => (p.key.isHandlerKey = true))
  return ret
}
#+end_src

red:Testing

#+html: <br>
#+begin_details v-on :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div v-on:click="onClick"/>`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details dynamic arg :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div v-on:[event]="handler"/>`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details dynamic arg with complex exp prefixing :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div v-on:[event(foo)]="handler"/>`, { prefixIdentifiers: true })
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details wrap as function if expression is inline statement :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div @click="i++" />`, { prefixIdentifiers: true })
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details handle multiple inline statement :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div @click="foo();bar()" />`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details inline statement :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div @click="foo($event)" />`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details multiple inline statement :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div @click="foo($event);bar()" />`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details not wrap as function :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node: node1 } = parseWithVOn(`<div @click="$event => foo($event)" />`)
const { node: node2 } = parseWithVOn(`<div @click="$event => {
  foo($event)
}" />`)
const { node: node3 } = parseWithVOn(`<div @click="function ($event) {
  foo($event)
}" />`)
logOn()

logg("node1.codegenNode.props.properties", node1.codegenNode.props.properties)
logg("node2.codegenNode.props.properties", node2.codegenNode.props.properties)
logg("node3.codegenNode.props.properties", node3.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details vnode hooks :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div v-on:vnode-mounted="onMounted" />`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details vue prefixed events :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node } = parseWithVOn(`<div @vue:before-update="onBeforeUpdate" />`)
logOn()

logg("node.codegenNode.props.properties", node.codegenNode.props.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details async function handler :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { node, root } = parseWithVOn(`<div @click="async () => await foo()" />`, {
  prefixIdentifiers: true,
  cacheHandlers: true
})
const { node: node1, root: root1 } = parseWithVOn(`<div @click="async function () { await foo() }" />`, {
  prefixIdentifiers: true,
  cacheHandlers: true
})
logOn()

logg(`root.cached=${root.cached}`)
logg("node.codegenNode.props.properties", node.codegenNode.props.properties)

logg(`root1.cached=${root1.cached}`)
logg("node1.codegenNode.props.properties", node1.codegenNode.props.properties)
#+end_src
#+end_details

*** transformOnce()

#+name: transformOnce
#+begin_src js -n -r
const seen = new WeakSet()

const transformOnce = (node, context) => {
  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
    if (seen.has(node) || context.inVOnce) {
      logg(`transformOnce node has seen`)
      return
    }
    seen.add(node)
    context.inVOnce = true
    context.helper(SET_BLOCK_TRACKING)
    return () => {
      context.inVOnce = false
      const cur = context.currentNode
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)
      }
    }
  }
}
#+end_src

red:Testing

#+html: <br>
#+begin_details as root node :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div :id="foo" v-once />`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.codegenNode", root.codegenNode)
#+end_src
#+end_details

#+html: <br>
#+begin_details on nested plain element :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div><div :id="foo" v-once /></div>`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.children[0].codegenNode", root.children[0].codegenNode)
#+end_src
#+end_details

#+html: <br>
#+begin_details on component :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div><Comp :id="foo" v-once /></div>`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.children[0].children[0].codegenNode", root.children[0].children[0].codegenNode)
#+end_src
#+end_details

#+html: <br>
#+begin_details on slot outlet :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div><slot v-once /></div>`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.children[0].children[0].codegenNode", root.children[0].children[0].codegenNode)
#+end_src
#+end_details

#+html: <br>
#+begin_details inside v-once :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div v-once><slot v-once /></div>`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.children[0].children[0].codegenNode", root.children[0].children[0].codegenNode)
#+end_src
#+end_details

#+html: <br>
#+begin_details with v-if/else :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div v-if="bool" v-once /><div v-else/>`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.children[0]", root.children[0])
logg("root.children[0].codegenNode", root.children[0].codegenNode)
#+end_src
#+end_details

#+html: <br>
#+begin_details with v-for :title-color red
#+begin_src js -n -r
<<transform-testing-utils>>

logOff()
const root = transformWithOnce(`<div v-for="i in list" v-once />`)
logOn()
logg(`root.cached=${root.cached}`)
logg(`root.helpers`, root.helpers)
logg("root.children[0]", root.children[0])
logg("root.children[0].codegenNode", root.children[0].codegenNode)
#+end_src
#+end_details

*** transformMemo()

#+begin_src html
<div v-memo="[x]" />
#+end_src

#+begin_src html
<Comp v-memo="[x]" />
#+end_src

#+begin_src html
<div v-if="ok" v-memo="[x]">
  <span>foo</span>
</div>
<Comp v-else v-memo="[x]" />
#+end_src

#+begin_src html
<div v-for="{ x, y } in list" :key="x" v-memo="[x, y === z]">
  <span>foobar</span>
</div>
#+end_src

#+begin_src html
<template v-for="{ x, y } in list" :key="x" v-memo="[x, y === z]">
  <span>foobar</span>
</template>
#+end_src

#+name: transformMemo
#+begin_src js -n -r
const memoSeen = new WeakSet()

const transformMemo = (node, context) => {
  if (node.type === NodeTypes.ELEMENT) {
    const dir = findDir(node, 'memo')
    if (!dir || memoSeen.has(node)) {
      return
    }
    memoSeen.add(node)
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode
      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {
        // non-component sub tree should be turned into a block
        if (node.tagType !== ElementTypes.COMPONENT) {
          makeBlock(codegenNode, context)
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(undefined, codegenNode),
          `_cache`,
          String(context.cached++)
        ])
      }
    }
  }
}
#+end_src
*** buildSlots()

#+name: buildSlots
#+begin_src js -n -r
const defaultFallback = createSimpleExpression(`undefined`, false)

// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
  if (
    node.type === NodeTypes.ELEMENT &&
    (node.tagType === ElementTypes.COMPONENT ||
      node.tagType === ElementTypes.TEMPLATE)
  ) {
    // We are only checking non-empty v-slot here
    // since we only care about slots that introduce scope variables.
    const vSlot = findDir(node, 'slot')
    if (vSlot) {
      const slotProps = vSlot.exp
      if (!__BROWSER__ && context.prefixIdentifiers) {
        slotProps && context.addIdentifiers(slotProps)
      }
      context.scopes.vSlot++
      return () => {
        if (!__BROWSER__ && context.prefixIdentifiers) {
          slotProps && context.removeIdentifiers(slotProps)
        }
        context.scopes.vSlot--
      }
    }
  }
}


// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
  let vFor
  if (
    isTemplateNode(node) &&
    node.props.some(isVSlot) &&
    (vFor = findDir(node, 'for'))
  ) {
    const result = (vFor.parseResult = parseForExpression(
      vFor.exp,
      context
    ))
    if (result) {
      const { value, key, index } = result
      const { addIdentifiers, removeIdentifiers } = context
      value && addIdentifiers(value)
      key && addIdentifiers(key)
      index && addIdentifiers(index)

      return () => {
        value && removeIdentifiers(value)
        key && removeIdentifiers(key)
        index && removeIdentifiers(index)
      }
    }
  }
}

const buildClientSlotFn = (props, children, loc) =>
  createFunctionExpression(
    props,
    children,
    false /* newline */,
    true /* isSlot */,
    children.length ? children[0].loc : loc
  )


// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn= buildClientSlotFn) {
  context.helper(WITH_CTX)

  const { children, loc } = node
  const slotsProperties = []
  const dynamicSlots= []

  // If the slot is inside a v-for or another v-slot, force it to be dynamic
  // since it likely uses a scope variable.
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0
  // with `prefixIdentifiers: true`, this can be further optimized to make
  // it dynamic only when the slot actually uses the scope variables.
  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {
    hasDynamicSlots = hasScopeRef(node, context.identifiers)
  }

  // 1. Check for slot with slotProps on component itself.
  //    <Comp v-slot="{ prop }"/>
  const onComponentSlot = findDir(node, 'slot', true)
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression('default', true),
        buildSlotFn(exp, children, loc)
      )
    )
  }

  // 2. Iterate through children and check for template slots
  //    <template v-slot:foo="{ prop }">
  let hasTemplateSlots = false
  let hasNamedDefaultSlot = false
  const implicitDefaultChildren = []
  const seenSlotNames = new Set()

  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i]
    let slotDir

    if ( (ref:buildSlots-implicitDefaultChildren-collect-start)
      !isTemplateNode(slotElement) ||
      !(slotDir = findDir(slotElement, 'slot', true))
    ) { // 收集不在 template v-slot 中的元素/组件，这些都会合并到默认插槽中去
      if (slotElement.type !== NodeTypes.COMMENT) {
        implicitDefaultChildren.push(slotElement)
      }
      continue
    } (ref:buildSlots-implicitDefaultChildren-collect-end)

    if (onComponentSlot) {
      logg(`buildSlots already has on-component slot - this is incorrect usage`)
      break
    }

    hasTemplateSlots = true
    const { children: slotChildren, loc: slotLoc } = slotElement
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir

    // check if name is dynamic.
    let staticSlotName
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`
    } else {
      hasDynamicSlots = true
    }

    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc)
    // check if this slot is conditional (v-if/v-for)
    let vIf
    let vElse
    let vFor
    if ((vIf = findDir(slotElement, 'if'))) {
      hasDynamicSlots = true
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction),
          defaultFallback
        )
      )
    } else if (
      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))
    ) {
      // find adjacent v-if
      let j = i
      let prev
      while (j--) {
        prev = children[j]
        if (prev.type !== NodeTypes.COMMENT) {
          break
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
        // remove node
        children.splice(i, 1)
        i--

        // attach this slot to previous conditional
        let conditional = dynamicSlots[
          dynamicSlots.length - 1
        ]
        while (
          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
        ) {
          conditional = conditional.alternate
        }
        conditional.alternate = vElse.exp
          ? createConditionalExpression(
              vElse.exp,
              buildDynamicSlot(slotName, slotFunction),
              defaultFallback
            )
          : buildDynamicSlot(slotName, slotFunction)
      }
    } else if ((vFor = findDir(slotElement, 'for'))) {
      hasDynamicSlots = true
      const parseResult =
        vFor.parseResult ||
        parseForExpression(vFor.exp , context)
      if (parseResult) {
        // Render the dynamic slots as an array and add it to the createSlot()
        // args. The runtime knows how to handle it appropriately.
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true /* force newline */
            )
          ])
        )
      }
    } else {
      // check duplicate static names
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          logg(`buildSlots seenSlotNames has slot name`)
          continue
        }
        seenSlotNames.add(staticSlotName)
        if (staticSlotName === 'default') {
          hasNamedDefaultSlot = true
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction))
    }
  }

  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children) => {
      const fn = buildSlotFn(props, children, loc)

      return createObjectProperty(`default`, fn)
    }

    if (!hasTemplateSlots) {
      // implicit default slot (on component)
      slotsProperties.push(buildDefaultSlotProperty(undefined, children))
    } else if ( (ref:buildSlots-implicitDefaultChildren-combine-start)
      implicitDefaultChildren.length &&
      // #3766
      // with whitespace: 'preserve', whitespaces between slots will end up in
      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
      implicitDefaultChildren.some(node => isNonWhitespaceContent(node))
    ) {
      // implicit default slot (mixed with named slots)
      if (hasNamedDefaultSlot) {
        logg(`buildSlots hasNamedDefaultSlot`)
      } else {
        // 合并到默认插槽
        slotsProperties.push(
          buildDefaultSlotProperty(undefined, implicitDefaultChildren)
        )
      }
    } (ref:buildSlots-implicitDefaultChildren-combine-end)
  }

  const slotFlag = hasDynamicSlots
    ? SlotFlags.DYNAMIC
    : hasForwardedSlots(node.children)
    ? SlotFlags.FORWARDED
    : SlotFlags.STABLE

  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  )
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ])
  }

  return {
    slots,
    hasDynamicSlots
  }
}

function buildDynamicSlot(name, fn) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ])
}

function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i]
    switch (child.type) {
      case NodeTypes.ELEMENT:
        if (
          child.tagType === ElementTypes.SLOT ||
          hasForwardedSlots(child.children)
        ) {
          return true
        }
        break
      case NodeTypes.IF:
        if (hasForwardedSlots(child.branches)) return true
        break
      case NodeTypes.IF_BRANCH:
      case NodeTypes.FOR:
        if (hasForwardedSlots(child.children)) return true
        break
      default:
        break
    }
  }
  return false
}

function isNonWhitespaceContent(node){
  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)
    return true
  return node.type === NodeTypes.TEXT
    ? !!node.content.trim()
    : isNonWhitespaceContent(node.content)
}
#+end_src

red:Testing

#+html: <br>
#+begin_details component slots :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(`<Comp><div/></Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("root", root)
logg("slots", slots)
logg("slots.properties[0]", slots.properties[0])
logg("slots.properties[0].value", slots.properties[0].value)
logg("slots.properties[1]", slots.properties[1])
logg("slots.properties[1].value", slots.properties[1].value)
#+end_src
#+end_details

#+html: <br>
#+begin_details on-component default slot :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(`<Comp v-slot="{ foo }">{{ foo }}{{ bar }}</Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("root", root)
logg("slots", slots)
logg("slots.properties[0].value.returns[0]", slots.properties[0].value.returns[0])
logg("slots.properties[0].value.returns[1]", slots.properties[0].value.returns[1])
#+end_src
#+end_details

#+html: <br>
#+begin_details on-component named slot :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(`<Comp v-slot:named="{ foo }">{{ foo }}{{ bar }}</Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("slots", slots)
const slot = slots.properties[0]
logg("slot", slot)
logg("slot.key", slot.key)
logg("slot.value.params", slot.value.params)
logg("slot.value.returns[0]", slot.value.returns[0])
logg("slot.value.returns[1]", slot.value.returns[1])
#+end_src
#+end_details

#+html: <br>
#+begin_details template named slot :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp>
    <template v-slot:one="{ foo }">
        {{ foo }}{{ bar }}
    </template>
    <template #two="{ bar }">
        {{ foo }}{{ bar }}
    </template>
  </Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("slots", slots)
slots.properties.forEach((p, i) => {
  logg(`slot ${i} - name = ${p.key.content}`, p.value)
})

#+end_src
#+end_details

#+html: <br>
#+begin_details on component dynamically named slot :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp v-slot:[named]="{foo}">{{foo}}{{bar}}</Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("slots", slots)
slots.properties.forEach((p, i) => {
  logg(`slot ${i} - name = ${p.key.content} - value`, p.value)
  logg(`slot ${i} - name = ${p.key.content} - returns`, p.value.returns)
})

#+end_src
#+end_details

#+html: <br>
#+begin_details named slots implicit default slot :title-color red
这种情况时，  ~<template #one>foo</template>bar<span/>~ 整个都会被当做默认插槽，而
不仅仅是 ~<template #one>foo</template>~ 这个，因为在处理插槽时，默认不在 template
里面的都合并到默认插槽中去。

相关代码： 收集
[[(buildSlots-implicitDefaultChildren-collect-start)]]~[[(buildSlots-implicitDefaultChildren-collect-end)]],
合并 [[(buildSlots-implicitDefaultChildren-combine-start)]]~[[(buildSlots-implicitDefaultChildren-combine-end)]]

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp>
     <template #one>foo</template>bar<span/>
   </Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("slots", slots)
slots.properties.forEach((p, i) => {
  logg(`slot ${i} - name = ${p.key.content} - value`, p.value)
  logg(`slot ${i} - name = ${p.key.content} - returns`, p.value.returns)
})

#+end_src
#+end_details

#+html: <br>
#+begin_details dynamically named slot :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp>
    <template v-slot:[one]="{ foo }">
        {{ foo }}{{ bar }}
    </template>
    <template #[two]="{ bar }">
        {{ foo }}{{ bar }}
    </template>
  </Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("slots", slots)
slots.properties.forEach((p, i) => {
  logg(`slot ${i} - name = ${p.key.content} - value`, p.value)
  logg(`slot ${i} - name = ${p.key.content} - returns`, p.value.returns)
})

#+end_src
#+end_details

#+html: <br>
#+begin_details nested slots scoping :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `
<Comp>
  <template #default="{ foo }">
    <Inner v-slot="{ bar }">
    {{ foo }}{{ bar }}{{ baz }}
    </Inner>
    {{ foo }}{{ bar }}{{ baz }}
  </template>
</Comp>`, {
  prefixIdentifiers: true
})
logOn()
logg("slots", slots)
slots.properties.forEach((p, i) => {
  logg(`slot ${i} - name = ${p.key.content} - value`, p.value)
  if (p.value.returns) {
     const returns = p.value.returns.filter(r => typeof r.content === 'string' ? !!r.content.trim() : true)
    logg(`slot ${i} - name = ${p.key.content} - returns`, returns)
  }
})
logg('inner slot returns', slots.properties[0].value.returns[1].codegenNode.children.properties[0].value.returns)
#+end_src
#+end_details

#+html: <br>
#+begin_details should force dynamic when inside v-for :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root } = parseWithSlots(
`<div v-for="i in list"><Comp v-slot="bar">foo</Comp></div>`
)
logOn()
const div = root.children[0].children[0].codegenNode
const comp = div.children[0]
logg(`div`, div)
logg(`comp`, comp)
logg(`comp.codegenNode.patchFlag(PatchFlags.DYNAMIC_SLOTS=${PatchFlags.DYNAMIC_SLOTS})`, comp.codegenNode.patchFlag)
#+end_src
#+end_details

#+html: <br>
#+begin_details force dynamic slots when using scope vars :title-color red
意思是只有当 slots 用到了当前局部变量的情况下才强制解析成动态插槽。

#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

function assertDynamicSlots(template) {
  logOff()
  const { root } = parseWithSlots(template, { prefixIdentifiers: true })
  logOn()
  let flag
  if (root.children[0].type === NodeTypes.FOR) {
    const div = root.children[0].children[0].codegenNode
    const comp = div.children[0]
    flag = comp.codegenNode.patchFlag
  } else {
    const innerComp = root.children[0].children[0]
    flag = innerComp.codegenNode.patchFlag
  }

  logg(`template`, template)
  logg(`flag=${flag}, PatchFlags.DYNAMIC_SLOTS=${PatchFlags.DYNAMIC_SLOTS}`)
  logBr()
}

assertDynamicSlots(`<div v-for="i in list"><Comp v-slot="bar">foo</Comp></div>`, false)

assertDynamicSlots(`<div v-for="i in list"><Comp v-slot="bar">{{ i }}</Comp></div>`, true)

// reference the component's own slot variable should not force dynamic slots
assertDynamicSlots(`<Comp v-slot="foo"><Comp v-slot="bar">{{ bar }}</Comp></Comp>`, false)

assertDynamicSlots(`<Comp v-slot="foo"><Comp v-slot="bar">{{ foo }}</Comp></Comp>`, true)

assertDynamicSlots(`<div v-for="i in list"><Comp v-slot="bar"><button @click="fn(i)" /></Comp></div>`, true)

assertDynamicSlots(`<div v-for="i in list"><Comp v-slot="bar"><button @click="fn()" /></Comp></div>`,false)
#+end_src
#+end_details

#+html: <br>
#+begin_details named slot with v-if :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp><template #one v-if="ok">hello</template></Comp>`)
logOn()
logg("slots", slots)
logg("slots.arguments[0].properties[0]", slots.arguments[0].properties[0])
logg("slots.arguments[1].elements[0]", slots.arguments[1].elements[0])
#+end_src
#+end_details

#+html: <br>
#+begin_details named slot with v-if+v-else-if+v-else :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp><template #one v-if="ok">hello</template><template #two v-else-if="orNot">bar</template><template #one v-else>bax</template></Comp>`)
logOn()
logg("slots", slots)
logg("slots.arguments[0].properties[0]", slots.arguments[0].properties[0])
const element = slots.arguments[1].elements[0]
logg("slots.arguments[1].elements[0]", element)
logg("slots.arguments[1].elements[0].alternate", element.alternate)
logg("slots.arguments[1].elements[0].alternate.test", element.alternate.test)
logg(
  "slots.arguments[1].elements[0].alternate.consequent.properties",
  element.alternate.consequent.properties)
logg(
  "slots.arguments[1].elements[0].alternate.alternate.properties",
  element.alternate.alternate.properties)
#+end_src
#+end_details

#+html: <br>
#+begin_details named slot with v-for :title-color red
#+begin_src js -n -r  :exports both
<<transform-testing-utils>>

logOff()
const { root, slots } = parseWithSlots(
  `<Comp><template v-for="name in list" #[name]>{{ name }}</template></Comp>`,
  { prefixIdentifiers: true }
)
logOn()
logg("slots", slots)
logg("slots.arguments[0].properties[0]", slots.arguments[0].properties[0])
logg("slots.arguments[1].elements[0]", slots.arguments[1].elements[0])
logg("slots.arguments[1].elements[0].arguments", slots.arguments[1].elements[0].arguments)
#+end_src
#+end_details

** codegenNode creators

这一节包含了所有用到的 ~createXxx~ 函数，这类函数是用来创建节点的 ~codegenNode~ 结构
的，每一种语法都会自己对应的创建函数，如： ~v-if~ 的分支节点就需要用到
[[createConditionalExpression][createConditionalExpression()]], [[createCallExpression][createCallExpression()]]。

这类函数并不复杂，只是返回不同类型和内容的一个对象。

#+name: ast-creators
#+begin_src js -n -r
<<createRoot>>
<<createVNodeCall>>
<<createArrayExpression>>
<<createObjectExpression>>
<<createObjectProperty>>
<<createSimpleExpression>>
<<createInterpolation>>
<<createCompoundExpression>>
<<createCallExpression>>
<<createFunctionExpression>>
<<createConditionalExpression>>
<<createCacheExpression>>
<<createBlockStatement>>
<<createTemplateLiteral>>
<<createIfStatement>>
<<createAssignmentExpression>>
<<createSequenceExpression>>
<<createReturnStatement>>
#+end_src

*** createRoot()

返回一个根节点结构：

#+name: createRoot
#+begin_src js -n -r
function createRoot(children, loc = locStub) {
  return {
    type: NodeTypes.ROOT,
    children, (ref:root-children)
    helpers: [],
    components: [], (ref:root-components)
    directives: [], (ref:root-directives)
    hoists: [], (ref:root-hoists)
    imports: [], (ref:root-imports)
    cached: 0,
    temps: 0,
    codegenNode: undefined, (ref:root-codegenNode)
    loc
  }
}
#+end_src

[[(root-children)][children]] 根节点下的子节点 AST 结构容器

[[(root-components)][components]] 引用的所有组件列表

[[(root-directives)][directives]] 解析后的指令结构

[[(root-hoists)][hoists]] 静态提升的节点，这个是不会发生变化的节点，如：纯文本节点，无 prop 无动态
children 的节点(不会发生的变化的都会被提升到 render 函数之外)。

[[(root-imports)][imports]] 引入的一引动依赖仓库

[[(root-codegenNode)][codegenNode]] 经过 ast parse -> transform -> codegen 之后生成的伪码字符串，这个就
是最后用来产生 render 函数的内容。

*** createVNodeCall()

这里开始是创建 codegenNode 的入口函数，这部分代码主要是在 [[https://github.com/vuejs/core/blob/main/packages/compiler-core/src/ast.ts][core/ast.ts at main ·
vuejs/core]] 中且都是以 ~createXxx~ 开头的函数，根据不同类型创建不同的 codgenNode 。

#+name: createVNodeCall
#+begin_src js -n -r
function createVNodeCall(
  context,
  tag,
  props,
  children,
  patchFlag,
  dynamicProps,
  directives,
  isBlock = false,
  disableTracking = false,
  isComponent = false,
  loc = locStub
) {
  if (context) {
    // 单个子节点用 block
    if (isBlock) {
      context.helper(OPEN_BLOCK) (ref:createVNodeCall-helper)
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))
    } else {
      // 多个节节点用 fragment
      context.helper(getVNodeHelper(context.inSSR, isComponent))
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES)
    }
  }

  return {
    type: NodeTypes.VNODE_CALL,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  }
}
#+end_src

这个函数[[(createVNodeCall-helper)]]中使用到了上下文中的[[(context-helper)][context.helper]] 函数，这个函
数的目的其实很简单，就是生成 api 名字([[https://github.com/vuejs/core/blob/main/packages/compiler-core/src/runtimeHelpers.ts][core/runtimeHelpers.ts at main ·
vuejs/core]])。

比如：这个用到两个创建元素/组件类型 api: block 和 vnode，分别是

~CREATE_BLOCK~ , ~CREATE_VNODE~ 它们在生成后的 render 函数中体现在

#+begin_src js -n -r
function render() {
  const { createBlock: _createBlock, createVNode: _createVNode } = Vue
  // ...
  // ...
}
#+end_src

后面的别名是在 [[codegen][codegen]] 阶段生成具体代码时增加的。
*** createArrayExpression()

#+name: createArrayExpression
#+begin_src js -n -r
function createArrayExpression(elements, loc = locStub) {
  return {
    type: NodeTypes.JS_ARRAY_EXPRESSION,
    loc,
    elements
  }
}
#+end_src

*** createObjectExpression()

#+name: createObjectExpression
#+begin_src js -n -r
function createObjectExpression(properties, loc = locStub) {
  return {
    type: NodeTypes.JS_OBJECT_EXPRESSION,
    loc,
    properties
  }
}
#+end_src

*** createObjectProperty()

#+name: createObjectProperty
#+begin_src js -n -r
function createObjectProperty(key, value) {
  return {
    type: NodeTypes.JS_PROPERTY,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  }
}
#+end_src

*** createSimpleExpression()

#+name: createSimpleExpression
#+begin_src js -n -r
function createSimpleExpression(
  content,
  isStatic = false,
  loc  = locStub,
  constType = ConstantTypes.NOT_CONSTANT
) {
  return {
    type: NodeTypes.SIMPLE_EXPRESSION,
    loc,
    content,
    isStatic,
    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType
  }
}
#+end_src
*** createInterpolation()

#+name: createInterpolation
#+begin_src js -n -r
function createInterpolation(content, loc) {
  return {
    type: NodeTypes.INTERPOLATION,
    loc,
    content: isString(content)
      ? createSimpleExpression(content, false, loc)
      : content
  }
}
#+end_src
*** createCompoundExpression()

#+name: createCompoundExpression
#+begin_src js -n -r
function createCompoundExpression(children, loc = locStub) {
  return {
    type: NodeTypes.COMPOUND_EXPRESSION,
    loc,
    children
  }
}
#+end_src
*** createCallExpression()

#+name: createCallExpression
#+begin_src js -n -r
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: NodeTypes.JS_CALL_EXPRESSION,
    loc,
    callee,
    arguments: args
  }
}
#+end_src
*** createFunctionExpression()

#+name: createFunctionExpression
#+begin_src js -n -r
function createFunctionExpression(
  params,
  returns = undefined,
  newline = false,
  isSlot = false,
  loc = locStub
) {
  return {
    type: NodeTypes.JS_FUNCTION_EXPRESSION,
    params,
    returns,
    newline,
    isSlot,
    loc
  }
}
#+end_src
*** createConditionalExpression()

生成条件语句([[transformIf][v-if]] 指令)： ~test ? consequent : alternate~

如果有 v-else-if 时候， alternate 结构会是个完整的 ~JS_CONDITIONAL_EXPRESSION~ ，
即： ~alternate: { test, consequent, alternate, ...}~ 的一个嵌套结构，所以：

~test ? consequent : test1 ? consequent1 : alternate~

如： ~<div v-if="bar"/><span v-else-if="foo"/><p v-else/>~

对应： ~bar ? div : foo ? span : p~

#+name: createConditionalExpression
#+begin_src js -n -r
function createConditionalExpression(
  test,
  consequent,
  alternate,
  newline = true
) {
  return {
    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  }
}
#+end_src

*** createCacheExpression()

#+name: createCacheExpression
#+begin_src js -n -r
function createCacheExpression(
  index,
  value,
  isVNode = false
) {
  return {
    type: NodeTypes.JS_CACHE_EXPRESSION,
    index,
    value,
    isVNode,
    loc: locStub
  }
}
#+end_src
*** createBlockStatement()

#+name: createBlockStatement
#+begin_src js -n -r
function createBlockStatement(body) {
  return {
    type: NodeTypes.JS_BLOCK_STATEMENT,
    body,
    loc: locStub
  }
}
#+end_src
*** createTemplateLiteral()

#+name: createTemplateLiteral
#+begin_src js -n -r
function createTemplateLiteral(elements) {
  return {
    type: NodeTypes.JS_TEMPLATE_LITERAL,
    elements,
    loc: locStub
  }
}
#+end_src
*** createIfStatement()

#+name: createIfStatement
#+begin_src js -n -r
function createIfStatement(test, consequent, alternate) {
  return {
    type: NodeTypes.JS_IF_STATEMENT,
    test,
    consequent,
    alternate,
    loc: locStub
  }
}
#+end_src
*** createAssignmentExpression()

#+name: createAssignmentExpression
#+begin_src js -n -r
function createAssignmentExpression(left, right) {
  return {
    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,
    left,
    right,
    loc: locStub
  }
}
#+end_src
*** createSequenceExpression()

#+name: createSequenceExpression
#+begin_src js -n -r
function createSequenceExpression(expressions) {
  return {
    type: NodeTypes.JS_SEQUENCE_EXPRESSION,
    expressions,
    loc: locStub
  }
}
#+end_src
*** createReturnStatement()

#+name: createReturnStatement
#+begin_src js -n -r
function createReturnStatement(returns) {
  return {
    type: NodeTypes.JS_RETURN_STATEMENT,
    returns,
    loc: locStub
  }
}
#+end_src
** hoists

#+name: hoists
#+begin_src js -n -r
function hoistStatic(root, context) {
  _walk(
    root,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  )
}

function isSingleElementRoot(
  root,
  child
) {
  const { children } = root
  return (
    children.length === 1 &&
    child.type === NodeTypes.ELEMENT &&
    !isSlotOutlet(child)
  )
}

function _walk(
  node,
  context,
  doNotHoistNode = false
) {
  const { children } = node
  const originalCount = children.length
  let hoistedCount = 0

  for (let i = 0; i < children.length; i++) {
    const child = children[i]
    // only plain elements & text calls are eligible for hoisting.
    if (
      child.type === NodeTypes.ELEMENT &&
      child.tagType === ElementTypes.ELEMENT
    ) {
      const constantType = doNotHoistNode
        ? ConstantTypes.NOT_CONSTANT
        : getConstantType(child, context)
      if (constantType > ConstantTypes.NOT_CONSTANT) {
        if (constantType >= ConstantTypes.CAN_HOIST) {
          child.codegenNode.patchFlag =
            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)
          child.codegenNode = context.hoist(child.codegenNode)
          hoistedCount++
          continue
        }
      } else {
        // node may contain dynamic children, but its props may be eligible for
        // hoisting.
        const codegenNode = child.codegenNode
        if (codegenNode.type === NodeTypes.VNODE_CALL) {
          const flag = getPatchFlag(codegenNode)
          if (
            (!flag ||
              flag === PatchFlags.NEED_PATCH ||
              flag === PatchFlags.TEXT) &&
            getGeneratedPropsConstantType(child, context) >=
              ConstantTypes.CAN_HOIST
          ) {
            const props = getNodeProps(child)
            if (props) {
              codegenNode.props = context.hoist(props)
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)
          }
        }
      }
    } else if (
      child.type === NodeTypes.TEXT_CALL &&
      getConstantType(child.content, context) >= ConstantTypes.CAN_HOIST
    ) {
      child.codegenNode = context.hoist(child.codegenNode)
      hoistedCount++
    }

    // walk further
    if (child.type === NodeTypes.ELEMENT) {
      const isComponent = child.tagType === ElementTypes.COMPONENT
      if (isComponent) {
        context.scopes.vSlot++
      }
      walk(child, context)
      if (isComponent) {
        context.scopes.vSlot--
      }
    } else if (child.type === NodeTypes.FOR) {
      // Do not hoist v-for single child because it has to be a block
      walk(child, context, child.children.length === 1)
    } else if (child.type === NodeTypes.IF) {
      for (let i = 0; i < child.branches.length; i++) {
        // Do not hoist v-if single child because it has to be a block
        walk(
          child.branches[i],
          context,
          child.branches[i].children.length === 1
        )
      }
    }
  }

  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node)
  }

  // all children were hoisted - the entire children array is hoistable.
  if (
    hoistedCount &&
    hoistedCount === originalCount &&
    node.type === NodeTypes.ELEMENT &&
    node.tagType === ElementTypes.ELEMENT &&
    node.codegenNode &&
    node.codegenNode.type === NodeTypes.VNODE_CALL &&
    isArray(node.codegenNode.children)
  ) {
    node.codegenNode.children = context.hoist(
      createArrayExpression(node.codegenNode.children)
    )
  }
}

function getConstantType(node, context) {
  const { constantCache } = context
  switch (node.type) {
    case NodeTypes.ELEMENT:
      if (node.tagType !== ElementTypes.ELEMENT) {
        return ConstantTypes.NOT_CONSTANT
      }
      const cached = constantCache.get(node)
      if (cached !== undefined) {
        return cached
      }
      const codegenNode = node.codegenNode
      if (codegenNode.type !== NodeTypes.VNODE_CALL) {
        return ConstantTypes.NOT_CONSTANT
      }
      if (
        codegenNode.isBlock &&
        node.tag !== 'svg' &&
        node.tag !== 'foreignObject'
      ) {
        return ConstantTypes.NOT_CONSTANT
      }
      const flag = getPatchFlag(codegenNode)
      if (!flag) {
        let returnType = ConstantTypes.CAN_STRINGIFY

        // Element itself has no patch flag. However we still need to check:

        // 1. Even for a node with no patch flag, it is possible for it to contain
        // non-hoistable expressions that refers to scope variables, e.g. compiler
        // injected keys or cached event handlers. Therefore we need to always
        // check the codegenNode's props to be sure.
        const generatedPropsType = getGeneratedPropsConstantType(node, context)
        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {
          constantCache.set(node, ConstantTypes.NOT_CONSTANT)
          return ConstantTypes.NOT_CONSTANT
        }
        if (generatedPropsType < returnType) {
          returnType = generatedPropsType
        }

        // 2. its children.
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context)
          if (childType === ConstantTypes.NOT_CONSTANT) {
            constantCache.set(node, ConstantTypes.NOT_CONSTANT)
            return ConstantTypes.NOT_CONSTANT
          }
          if (childType < returnType) {
            returnType = childType
          }
        }

        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
        // type, check if any of the props can cause the type to be lowered
        // we can skip can_patch because it's guaranteed by the absence of a
        // patchFlag.
        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i]
            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {
              const expType = getConstantType(p.exp, context)
              if (expType === ConstantTypes.NOT_CONSTANT) {
                constantCache.set(node, ConstantTypes.NOT_CONSTANT)
                return ConstantTypes.NOT_CONSTANT
              }
              if (expType < returnType) {
                returnType = expType
              }
            }
          }
        }

        // only svg/foreignObject could be block here, however if they are
        // static then they don't need to be blocks since there will be no
        // nested updates.
        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK)
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          )
          codegenNode.isBlock = false
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))
        }

        constantCache.set(node, returnType)
        return returnType
      } else {
        constantCache.set(node, ConstantTypes.NOT_CONSTANT)
        return ConstantTypes.NOT_CONSTANT
      }
    case NodeTypes.TEXT:
    case NodeTypes.COMMENT:
      return ConstantTypes.CAN_STRINGIFY
    case NodeTypes.IF:
    case NodeTypes.FOR:
    case NodeTypes.IF_BRANCH:
      return ConstantTypes.NOT_CONSTANT
    case NodeTypes.INTERPOLATION:
    case NodeTypes.TEXT_CALL:
      return getConstantType(node.content, context)
    case NodeTypes.SIMPLE_EXPRESSION:
      return node.constType
    case NodeTypes.COMPOUND_EXPRESSION:
      let returnType = ConstantTypes.CAN_STRINGIFY
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i]
        if (isString(child) || isSymbol(child)) {
          continue
        }
        const childType = getConstantType(child, context)
        if (childType === ConstantTypes.NOT_CONSTANT) {
          return ConstantTypes.NOT_CONSTANT
        } else if (childType < returnType) {
          returnType = childType
        }
      }
      return returnType
    default:
      return ConstantTypes.NOT_CONSTANT
  }
}

const allowHoistedHelperSet = new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
])

function getConstantTypeOfHelperCall(value, context){
  if (
    value.type === NodeTypes.JS_CALL_EXPRESSION &&
    !isString(value.callee) &&
    allowHoistedHelperSet.has(value.callee)
  ) {
    const arg = value.arguments[0]
    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
      return getConstantType(arg, context)
    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {
      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
      return getConstantTypeOfHelperCall(arg, context)
    }
  }
  return ConstantTypes.NOT_CONSTANT
}

function getGeneratedPropsConstantType(node, context) {
  let returnType = ConstantTypes.CAN_STRINGIFY
  const props = getNodeProps(node)
  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {
    const { properties } = props
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i]
      const keyType = getConstantType(key, context)
      if (keyType === ConstantTypes.NOT_CONSTANT) {
        return keyType
      }
      if (keyType < returnType) {
        returnType = keyType
      }
      let valueType
      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {
        valueType = getConstantType(value, context)
      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {
        // some helper calls can be hoisted,
        // such as the `normalizeProps` generated by the compiler for pre-normalize class,
        // in this case we need to respect the ConstantType of the helper's arguments
        valueType = getConstantTypeOfHelperCall(value, context)
      } else {
        valueType = ConstantTypes.NOT_CONSTANT
      }
      if (valueType === ConstantTypes.NOT_CONSTANT) {
        return valueType
      }
      if (valueType < returnType) {
        returnType = valueType
      }
    }
  }
  return returnType
}

function getNodeProps(node) {
  const codegenNode = node.codegenNode
  if (codegenNode.type === NodeTypes.VNODE_CALL) {
    return codegenNode.props
  }
}

function getPatchFlag(node) {
  const flag = node.patchFlag
  return flag ? parseInt(flag, 10) : undefined
}

#+end_src
* codegen
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: cc-codegen
:END:

#+html: <br>
#+begin_details utils :title-color green
#+name: codegen-utils
#+begin_src js -n -r
const PURE_ANNOTATION = `/*#__PURE__*/`

function isText$1(n) {
  return (
    isString(n) ||
    n.type === NodeTypes.SIMPLE_EXPRESSION ||
    n.type === NodeTypes.TEXT ||
    n.type === NodeTypes.INTERPOLATION ||
    n.type === NodeTypes.COMPOUND_EXPRESSION
  )
}

// 过滤掉后面空值参数fn(a, b, c, null, undefined, '') => fn(a,b,c)
function genNullableArgs(args) {
  let i = args.length
  while (i--) {
    if (args[i] != null) break
  }
  return args.slice(0, i + 1).map(arg => arg || `null`)
}

// 生成对象的 key 值，可能是个表达式，如： { [a + b + c]: value }
function genExpressionAsPropertyKey(node, context) {
  const { push } = context
  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
    push(`[`)
    genCompoundExpression(node, context)
    push(`]`)
  } else if (node.isStatic) {
    // only quote keys if necessary
    const text = isSimpleIdentifier(node.content)
      ? node.content
      : JSON.stringify(node.content)
    push(text, node)
  } else {
    push(`[${node.content}]`, node)
  }
}
#+end_src
#+end_details

#+name: codegen
#+begin_src js -n -r
<<codegen-utils>>
<<createCodegenContext>>
<<genModulePreamble>>
<<genImports>>
<<genFunctionPreamble>>
<<genHoists>>
<<genAssets>>
<<genNode>>
<<genNodeListAsArray>>
<<generate>>
#+end_src

** generate()

#+name: generate
#+begin_src js -n -r

function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options)
  if (options.onContextCreated) options.onContextCreated(context)
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context

  const hasHelpers = ast.helpers.length > 0
  const useWithBlock = !prefixIdentifiers && mode !== 'module'
  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'
  const isSetupInlined = !__BROWSER__ && !!options.inline

  // preambles
  // in setup() inline mode, the preamble is generated in a sub context
  // and returned separately.
  const preambleContext = isSetupInlined
    ? createCodegenContext(ast, options)
    : context
  if (!__BROWSER__ && mode === 'module') {
    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)
  } else {
    genFunctionPreamble(ast, preambleContext)
  }
  // enter render function
  const functionName = ssr ? `ssrRender` : `render`
  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']
  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {
    // binding optimization args
    args.push('$props', '$setup', '$data', '$options')
  }
  const signature =
    !__BROWSER__ && options.isTS
      ? args.map(arg => `${arg}: any`).join(',')
      : args.join(', ')

  if (isSetupInlined) {
    push(`(${signature}) => {`)
  } else {
    push(`function ${functionName}(${signature}) {`)
  }
  indent()

  if (useWithBlock) {
    push(`with (_ctx) {`)
    indent()
    // function mode const declarations should be inside with block
    // also they should be renamed to avoid collision with user properties
    if (hasHelpers) {
      push(
        `const { ${ast.helpers
          .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
          .join(', ')} } = _Vue`
      )
      push(`\n`)
      newline()
    }
  }

  // generate asset resolution statements
  if (ast.components.length) {
    genAssets(ast.components, 'component', context)
    if (ast.directives.length || ast.temps > 0) {
      newline()
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, 'directive', context)
    if (ast.temps > 0) {
      newline()
    }
  }

  // 临时变量
  if (ast.temps > 0) {
    push(`let `)
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`)
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`\n`)
    newline()
  }

  // generate the VNode tree expression
  if (!ssr) {
    push(`return `)
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context)
  } else {
    push(`null`)
  }

  if (useWithBlock) {
    deindent()
    push(`}`)
  }

  deindent()
  push(`}`)

  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : undefined
  }
}
#+end_src

** createCodegenContext()

#+name: createCodegenContext
#+begin_src js -n -r
function createCodegenContext(
  ast,
  {
    mode = 'function',
    prefixIdentifiers = mode === 'module',
    sourceMap = false,
    filename = `template.vue.html`,
    scopeId = null,
    optimizeImports = false,
    runtimeGlobalName = `Vue`,
    runtimeModuleName = `vue`,
    ssrRuntimeModuleName = 'vue/server-renderer',
    ssr = false,
    isTS = false,
    inSSR = false
  }
) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: undefined,
    helper(key) {
      return `_${helperNameMap[key]}`
    },
    push(code, node) {
      context.code += code
      if (!__BROWSER__ && context.map) {
        if (node) {
          let name
          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {
            const content = node.content.replace(/^_ctx\./, '')
            if (content !== node.content && isSimpleIdentifier(content)) {
              name = content
            }
          }
          addMapping(node.loc.start, name)
        }
        advancePositionWithMutation(context, code)
        if (node && node.loc !== locStub) {
          addMapping(node.loc.end)
        }
      }
    },
    indent() {
      newline(++context.indentLevel)
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel
      } else {
        newline(--context.indentLevel)
      }
    },
    newline() {
      newline(context.indentLevel)
    }
  }

  function newline(n) {
    context.push('\n' + `  `.repeat(n))
  }

  function addMapping(loc, name) {
    context.map.addMapping({
      name,
      source: context.filename,
      original: {
        line: loc.line,
        column: loc.column - 1 // source-map column is 0 based
      },
      generated: {
        line: context.line,
        column: context.column - 1
      }
    })
  }

  return context
}
#+end_src
** genModulePreamble()

#+name: genModulePreamble
#+begin_src js -n -r

function genModulePreamble(ast, context, genScopeId, inline) {
  const {
    push,
    newline,
    optimizeImports,
    runtimeModuleName,
    ssrRuntimeModuleName
  } = context

  if (genScopeId && ast.hoists.length) {
    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)
  }

  // generate import statements for helpers
  if (ast.helpers.length) {
    if (optimizeImports) {
      // when bundled with webpack with code-split, calling an import binding
      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,
      // incurring both payload size increase and potential perf overhead.
      // therefore we assign the imports to variables (which is a constant ~50b
      // cost per-component instead of scaling with template size)
      push(
        `import { ${ast.helpers
          .map(s => helperNameMap[s])
          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`
      )
      push(
        `\n// Binding optimization for webpack code-split\nconst ${ast.helpers
          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)
          .join(', ')}\n`
      )
    } else {
      push(
        `import { ${ast.helpers
          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)
          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`
      )
    }
  }

  if (ast.ssrHelpers && ast.ssrHelpers.length) {
    push(
      `import { ${ast.ssrHelpers
        .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)
        .join(', ')} } from "${ssrRuntimeModuleName}"\n`
    )
  }

  if (ast.imports.length) {
    genImports(ast.imports, context)
    newline()
  }

  genHoists(ast.hoists, context)
  newline()

  if (!inline) {
    push(`export `)
  }
}
#+end_src
** genImports()

#+name: genImports
#+begin_src js -n -r
function genImports(importsOptions, context) {
  if (!importsOptions.length) {
    return
  }
  importsOptions.forEach(imports => {
    context.push(`import `)
    genNode(imports.exp, context)
    context.push(` from '${imports.path}'`)
    context.newline()
  })
}
#+end_src
** genFunctionPreamble()

#+name: genFunctionPreamble
#+begin_src js -n -r
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context
  const VueBinding =
    !__BROWSER__ && ssr
      ? `require(${JSON.stringify(runtimeModuleName)})`
      : runtimeGlobalName
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`
  // Generate const declaration for helpers
  // In prefix mode, we place the const declaration at top so it's done
  // only once; But if we not prefixing, we place the declaration inside the
  // with block so it doesn't incur the `in` check cost for every helper access.
  if (ast.helpers.length > 0) {
    if (!__BROWSER__ && prefixIdentifiers) {
      push(
        `const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\n`
      )
    } else {
      // "with" mode.
      // save Vue in a separate variable to avoid collision
      push(`const _Vue = ${VueBinding}\n`)
      // in "with" mode, helpers are declared inside the with block to avoid
      // has check cost, but hoists are lifted out of the function - we need
      // to provide the helper here.
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ]
          .filter(helper => ast.helpers.includes(helper))
          .map(aliasHelper)
          .join(', ')
        push(`const { ${staticHelpers} } = _Vue\n`)
      }
    }
  }
  // generate variables for ssr helpers
  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {
    // ssr guarantees prefixIdentifier: true
    push(
      `const { ${ast.ssrHelpers
        .map(aliasHelper)
        .join(', ')} } = require("${ssrRuntimeModuleName}")\n`
    )
  }
  genHoists(ast.hoists, context)
  newline()
  push(`return `)
}
#+end_src
** genHoists()

#+name: genHoists
#+begin_src js -n -r
function genHoists(hoists, context) {
  if (!hoists.length) {
    return
  }
  context.pure = true
  const { push, newline, helper, scopeId, mode } = context
  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'
  newline()

  // generate inlined withScopeId helper
  if (genScopeId) {
    push(
      `const _withScopeId = n => (${helper(
        PUSH_SCOPE_ID
      )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`
    )
    newline()
  }

  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i]
    if (exp) {
      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL
      push(
        `const _hoisted_${i + 1} = ${
          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``
        }`
      )
      genNode(exp, context)
      if (needScopeIdWrapper) {
        push(`)`)
      }
      newline()
    }
  }

  context.pure = false
}
#+end_src
** genAssets()

#+name: genAssets
#+begin_src js -n -r
// type = 'component' | 'directive' | 'filter'
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === 'component'
      ? RESOLVE_COMPONENT
      : RESOLVE_DIRECTIVE
  )
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i]
    // potential component implicit self-reference inferred from SFC filename
    const maybeSelfReference = id.endsWith('__self')
    if (maybeSelfReference) {
      id = id.slice(0, -6)
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${
        maybeSelfReference ? `, true` : ``
      })${isTS ? `!` : ``}`
    )
    if (i < assets.length - 1) {
      newline()
    }
  }
}
#+end_src
** genNode()

#+name: gen-node-fns
#+begin_src js -n -r
<<genText>>
<<genExpression>>
<<genInterpolation>>
<<genCompoundExpression>>
<<genComment>>
<<genVNodeCall>>
<<genCallExpression>>
<<genObjectExpression>>
<<genArrayExpression>>
<<genFunctionExpression>>
<<genConditionalExpression>>
<<genCacheExpression>>
<<genNodeList>>
<<genTemplateLiteral>>
<<genIfStatement>>
<<genAssignmentExpression>>
<<genSequenceExpression>>
<<genReturnStatement>>
#+end_src

#+name: genNode
#+begin_src js -n -r
<<gen-node-fns>>

function genNode(node, context) {
  if (isString(node)) {
    context.push(node)
    return
  }
  if (isSymbol(node)) {
    context.push(context.helper(node))
    return
  }
  switch (node.type) {
    case NodeTypes.ELEMENT:
    case NodeTypes.IF:
    case NodeTypes.FOR:
      genNode(node.codegenNode, context)
      break
    case NodeTypes.TEXT:
      genText(node, context)
      break
    case NodeTypes.SIMPLE_EXPRESSION:
      genExpression(node, context)
      break
    case NodeTypes.INTERPOLATION:
      genInterpolation(node, context)
      break
    case NodeTypes.TEXT_CALL:
      genNode(node.codegenNode, context)
      break
    case NodeTypes.COMPOUND_EXPRESSION:
      genCompoundExpression(node, context)
      break
    case NodeTypes.COMMENT:
      genComment(node, context)
      break
    case NodeTypes.VNODE_CALL:
      genVNodeCall(node, context)
      break

    case NodeTypes.JS_CALL_EXPRESSION:
      genCallExpression(node, context)
      break
    case NodeTypes.JS_OBJECT_EXPRESSION:
      genObjectExpression(node, context)
      break
    case NodeTypes.JS_ARRAY_EXPRESSION:
      genArrayExpression(node, context)
      break
    case NodeTypes.JS_FUNCTION_EXPRESSION:
      genFunctionExpression(node, context)
      break
    case NodeTypes.JS_CONDITIONAL_EXPRESSION:
      genConditionalExpression(node, context)
      break
    case NodeTypes.JS_CACHE_EXPRESSION:
      genCacheExpression(node, context)
      break
    case NodeTypes.JS_BLOCK_STATEMENT:
      genNodeList(node.body, context, true, false)
      break

    // SSR only types
    case NodeTypes.JS_TEMPLATE_LITERAL:
      !__BROWSER__ && genTemplateLiteral(node, context)
      break
    case NodeTypes.JS_IF_STATEMENT:
      !__BROWSER__ && genIfStatement(node, context)
      break
    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:
      !__BROWSER__ && genAssignmentExpression(node, context)
      break
    case NodeTypes.JS_SEQUENCE_EXPRESSION:
      !__BROWSER__ && genSequenceExpression(node, context)
      break
    case NodeTypes.JS_RETURN_STATEMENT:
      !__BROWSER__ && genReturnStatement(node, context)
      break

    /* istanbul ignore next */
    case NodeTypes.IF_BRANCH:
      // noop
      break
    default:
      logg(`unhandled codegen node type: ${node.type}`)
  }
}
#+end_src

*** genText()

#+name: genText
#+begin_src js -n -r
function genText(node, context) {
  context.push(JSON.stringify(node.content), node)
}
#+end_src
*** genExpression()

#+name: genExpression
#+begin_src js -n -r
function genExpression(node, context) {
  const { content, isStatic } = node
  context.push(isStatic ? JSON.stringify(content) : content, node)
}
#+end_src
*** genInterpolation()

#+name: genInterpolation
#+begin_src js -n -r
function genInterpolation(node, context) {
  const { push, helper, pure } = context
  if (pure) push(PURE_ANNOTATION)
  push(`${helper(TO_DISPLAY_STRING)}(`)
  genNode(node.content, context)
  push(`)`)
}
#+end_src
*** genCompoundExpression()

#+name: genCompoundExpression
#+begin_src js -n -r
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i]
    if (isString(child)) {
      context.push(child)
    } else {
      genNode(child, context)
    }
  }
}
#+end_src
*** genComment()

#+name: genComment
#+begin_src js -n -r
function genComment(node, context) {
  const { push, helper, pure } = context
  if (pure) {
    push(PURE_ANNOTATION)
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)
}
#+end_src
*** genVNodeCall()

#+name: genVNodeCall
#+begin_src js -n -r
function genVNodeCall(node, context) {
  const { push, helper, pure } = context
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`)
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)
  }
  if (pure) {
    push(PURE_ANNOTATION)
  }
  const callHelper = isBlock
    ? getVNodeBlockHelper(context.inSSR, isComponent)
    : getVNodeHelper(context.inSSR, isComponent)
  push(helper(callHelper) + `(`, node)
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  )
  push(`)`)
  if (isBlock) {
    push(`)`)
  }
  if (directives) {
    push(`, `)
    genNode(directives, context)
    push(`)`)
  }
}
#+end_src
*** genCallExpression()

#+name: genCallExpression
#+begin_src js -n -r
// JavaScript
function genCallExpression(node, context) {
  const { push, helper, pure } = context
  const callee = isString(node.callee) ? node.callee : helper(node.callee)
  if (pure) {
    push(PURE_ANNOTATION)
  }
  push(callee + `(`, node)
  genNodeList(node.arguments, context)
  push(`)`)
}
#+end_src
*** genObjectExpression()

#+name: genObjectExpression
#+begin_src js -n -r
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context
  const { properties } = node
  if (!properties.length) {
    push(`{}`, node)
    return
  }
  const multilines =
    properties.length > 1 ||
    ((!__BROWSER__ || __DEV__) &&
      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))
  push(multilines ? `{` : `{ `)
  multilines && indent()
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i]
    // key
    genExpressionAsPropertyKey(key, context)
    push(`: `)
    // value
    genNode(value, context)
    if (i < properties.length - 1) {
      // will only reach this if it's multilines
      push(`,`)
      newline()
    }
  }
  multilines && deindent()
  push(multilines ? `}` : ` }`)
}
#+end_src
*** genArrayExpression()

#+name: genArrayExpression
#+begin_src js -n -r
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context)
}
#+end_src
*** genFunctionExpression()

#+name: genFunctionExpression
#+begin_src js -n -r
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context
  const { params, returns, body, newline, isSlot } = node
  if (isSlot) {
    // wrap slot functions with owner context
    push(`_${helperNameMap[WITH_CTX]}(`)
  }
  push(`(`, node)
  if (isArray(params)) {
    genNodeList(params, context)
  } else if (params) {
    genNode(params, context)
  }
  push(`) => `)
  if (newline || body) {
    push(`{`)
    indent()
  }
  if (returns) {
    if (newline) {
      push(`return `)
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context)
    } else {
      genNode(returns, context)
    }
  } else if (body) {
    genNode(body, context)
  }
  if (newline || body) {
    deindent()
    push(`}`)
  }
  if (isSlot) {
    push(`)`)
  }
}
#+end_src
*** genConditionalExpression()

#+name: genConditionalExpression
#+begin_src js -n -r
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node
  const { push, indent, deindent, newline } = context
  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {
    const needsParens = !isSimpleIdentifier(test.content)
    needsParens && push(`(`)
    genExpression(test, context)
    needsParens && push(`)`)
  } else {
    push(`(`)
    genNode(test, context)
    push(`)`)
  }
  needNewline && indent()
  context.indentLevel++
  needNewline || push(` `)
  push(`? `)
  genNode(consequent, context)
  context.indentLevel--
  needNewline && newline()
  needNewline || push(` `)
  push(`: `)
  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION
  if (!isNested) {
    context.indentLevel++
  }
  genNode(alternate, context)
  if (!isNested) {
    context.indentLevel--
  }
  needNewline && deindent(true /* without newline */)
}
#+end_src
*** genCacheExpression()

#+name: genCacheExpression
#+begin_src js -n -r
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context
  push(`_cache[${node.index}] || (`)
  if (node.isVNode) {
    indent()
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)
    newline()
  }
  push(`_cache[${node.index}] = `)
  genNode(node.value, context)
  if (node.isVNode) {
    push(`,`)
    newline()
    push(`${helper(SET_BLOCK_TRACKING)}(1),`)
    newline()
    push(`_cache[${node.index}]`)
    deindent()
  }
  push(`)`)
}
#+end_src
*** genNodeList()

#+name: genNodeList
#+begin_src js -n -r
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i]
    if (isString(node)) {
      push(node)
    } else if (isArray(node)) {
      genNodeListAsArray(node, context)
    } else {
      genNode(node, context)
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(',')
        newline()
      } else {
        comma && push(', ')
      }
    }
  }
}
#+end_src
*** genTemplateLiteral()

#+name: genTemplateLiteral
#+begin_src js -n -r
function genTemplateLiteral(node, context) {
  const { push, indent, deindent } = context
  push('`')
  const l = node.elements.length
  const multilines = l > 3
  for (let i = 0; i < l; i++) {
    const e = node.elements[i]
    if (isString(e)) {
      push(e.replace(/(`|\$|\\)/g, '\\$1'))
    } else {
      push('${')
      if (multilines) indent()
      genNode(e, context)
      if (multilines) deindent()
      push('}')
    }
  }
  push('`')
}
#+end_src
*** genIfStatement()

#+name: genIfStatement
#+begin_src js -n -r
function genIfStatement(node, context) {
  const { push, indent, deindent } = context
  const { test, consequent, alternate } = node
  push(`if (`)
  genNode(test, context)
  push(`) {`)
  indent()
  genNode(consequent, context)
  deindent()
  push(`}`)
  if (alternate) {
    push(` else `)
    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {
      genIfStatement(alternate, context)
    } else {
      push(`{`)
      indent()
      genNode(alternate, context)
      deindent()
      push(`}`)
    }
  }
}
#+end_src
*** genAssignmentExpression()

#+name: genAssignmentExpression
#+begin_src js -n -r
function genAssignmentExpression(node, context) {
  genNode(node.left, context)
  context.push(` = `)
  genNode(node.right, context)
}
#+end_src
*** genSequenceExpression()

#+name: genSequenceExpression
#+begin_src js -n -r
function genSequenceExpression(node, context) {
  context.push(`(`)
  genNodeList(node.expressions, context)
  context.push(`)`)
}
#+end_src
*** genReturnStatement()

#+name: genReturnStatement
#+begin_src js -n -r
function genReturnStatement({ returns }, context) {
  context.push(`return `)
  if (isArray(returns)) {
    genNodeListAsArray(returns, context)
  } else {
    genNode(returns, context)
  }
}
#+end_src
** genNodeListAsArray()

#+name: genNodeListAsArray
#+begin_src js -n -r
function genNodeListAsArray(nodes, context) {
  const multilines =
    nodes.length > 3 ||
    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))
  context.push(`[`)
  multilines && context.indent()
  genNodeList(nodes, context, multilines)
  multilines && context.deindent()
  context.push(`]`)
}
#+end_src
** Testing

#+name: codegen-testing-utils
#+begin_src js -n -r
<<globalVars>>
<<ast-creators>>
<<codegen>>

function _createRoot(options = {}) {
  return {
    type: NodeTypes.ROOT,
    children: [],
    helpers: [],
    components: [],
    directives: [],
    imports: [],
    hoists: [],
    cached: 0,
    temps: 0,
    codegenNode: createSimpleExpression(`null`, false),
    loc: locStub,
    ...options
  }
}
#+end_src

#+html: <br>
#+begin_details module mode preamble :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  helpers: [CREATE_VNODE, RESOLVE_DIRECTIVE]
})
const { code } = generate(root, { mode: 'module' })
logg("code", code)
#+end_src

#+RESULTS:
: --------- code ---------
: import { createVNode as _createVNode, resolveDirective as _resolveDirective } from "vue"
:
: export function render(_ctx, _cache) {
:   return null
: }
: undefined

#+end_details

#+html: <br>
#+begin_details module mode preamble with optimizeImports=true :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  helpers: [CREATE_VNODE, RESOLVE_DIRECTIVE]
})
const { code } = generate(root, { mode: 'module', optimizeImports: true })
logg("code", code)
#+end_src

#+RESULTS:
#+begin_example
--------- code ---------
import { createVNode, resolveDirective } from "vue"

// Binding optimization for webpack code-split
const _createVNode = createVNode, _resolveDirective = resolveDirective

export function render(_ctx, _cache) {
  return null
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details function mode preamble with optimizeImports=true :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  helpers: [CREATE_VNODE, RESOLVE_DIRECTIVE]
})
const { code } = generate(root, { mode: 'function' })
logg("code", code)
#+end_src

#+RESULTS:
#+begin_example
--------- code ---------
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createVNode: _createVNode, resolveDirective: _resolveDirective } = _Vue

    return null
  }
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details function mode preamble :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  helpers: [CREATE_VNODE, RESOLVE_DIRECTIVE]
})
const { code } = generate(root, { mode: 'function', prefixIdentifiers: true })
logg("code", code)
#+end_src

#+RESULTS:
: --------- code ---------
: const { createVNode: _createVNode, resolveDirective: _resolveDirective } = Vue
:
: return function render(_ctx, _cache) {
:   return null
: }
: undefined
#+end_details

#+html: <br>
#+begin_details assets+temps :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  components: [`Foo`, `bar-baz`, `barbaz`, `Qux__self`],
  directives: [`my_dir_0`, `my_dir_1`],
  temps: 3
})
const { code } = generate(root, { mode: 'function' })
logg("code", code)
#+end_src

red:temps

#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  temps: 3
})
const { code } = generate(root)
logg("code", code)
#+end_src
#+end_details

#+html: <br>
#+begin_details hoists :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  hoists: [
    createSimpleExpression(`hello`, false, locStub),
    createObjectExpression(
      [
        createObjectProperty(
          createSimpleExpression(`id`, true, locStub),
          createSimpleExpression(`foo`, true, locStub)
        )
      ],
      locStub
    )
  ]
})
const { code } = generate(root)
logg("code", code)
#+end_src
#+end_details

#+html: <br>
#+begin_details static text :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: {
    type: NodeTypes.TEXT,
    content: 'hello',
    loc: locStub
  }
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
: --------- code ---------
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return "hello"
:   }
: }
: undefined

#+end_details

#+html: <br>
#+begin_details interpolation :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createInterpolation('hello', locStub)
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+end_details

#+html: <br>
#+begin_details compound expression :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createCompoundExpression([
    `_ctx.`,
    createSimpleExpression(`foo`, false, locStub),
    ` + `,
    {
      type: NodeTypes.INTERPOLATION,
      loc: locStub,
      content: createSimpleExpression(`bar`, false, locStub)
    },
    // nested compound
    createCompoundExpression([` + `, `nested`])
  ])
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+end_details

#+html: <br>
#+begin_details ifNode :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: {
    type: NodeTypes.IF,
    loc: locStub,
    branches: [],
    codegenNode: createConditionalExpression(
      createSimpleExpression('foo', false),
      createSimpleExpression('bar', false),
      createSimpleExpression('baz', false)
    )
  }
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+end_details

#+html: <br>
#+begin_details forNode :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: {
          type: NodeTypes.FOR,
          loc: locStub,
          source: createSimpleExpression('foo', false),
          valueAlias: undefined,
          keyAlias: undefined,
          objectIndexAlias: undefined,
          children: [],
          parseResult: {},
          codegenNode: {
            type: NodeTypes.VNODE_CALL,
            tag: FRAGMENT,
            isBlock: true,
            disableTracking: true,
            props: undefined,
            children: createCallExpression(RENDER_LIST),
            patchFlag: '1',
            dynamicProps: undefined,
            directives: undefined,
            loc: locStub
          }
        }
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
: --------- code ---------
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(), 1))
:   }
: }
: undefined

#+end_details

#+html: <br>
#+begin_details forNode with constant expression :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: {
          type: NodeTypes.FOR,
          loc: locStub,
          source: createSimpleExpression(
            '1 + 2',
            false,
            locStub,
            ConstantTypes.CAN_STRINGIFY
          ),
          valueAlias: undefined,
          keyAlias: undefined,
          objectIndexAlias: undefined,
          children: [],
          parseResult: {} ,
          codegenNode: {
            type: NodeTypes.VNODE_CALL,
            tag: FRAGMENT,
            isBlock: true,
            disableTracking: false,
            props: undefined,
            children: createCallExpression(RENDER_LIST),
            patchFlag: genFlagText(PatchFlags.STABLE_FRAGMENT),
            dynamicProps: undefined,
            directives: undefined,
            loc: locStub
          }
        }
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
: --------- code ---------
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return (_openBlock(), _createElementBlock(_Fragment, null, _renderList(), 64 /* STABLE_FRAGMENT */))
:   }
: }
: undefined
#+end_details

#+html: <br>
#+begin_details Element (callExpression + objectExpression + TemplateChildNode[]) :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createElementWithCodegen(
          // string
          `"div"`,
          // ObjectExpression
          createObjectExpression(
            [
              createObjectProperty(
                createSimpleExpression(`id`, true, locStub),
                createSimpleExpression(`foo`, true, locStub)
              ),
              createObjectProperty(
                createSimpleExpression(`prop`, false, locStub),
                createSimpleExpression(`bar`, false, locStub)
              ),
              // compound expression as computed key
              createObjectProperty(
                {
                  type: NodeTypes.COMPOUND_EXPRESSION,
                  loc: locStub,
                  children: [
                    `foo + `,
                    createSimpleExpression(`bar`, false, locStub)
                  ]
                },
                createSimpleExpression(`bar`, false, locStub)
              )
            ],
            locStub
          ),
          // ChildNode[]
          [
            createElementWithCodegen(
              `"p"`,
              createObjectExpression(
                [
                  createObjectProperty(
                    // should quote the key!
                    createSimpleExpression(`some-key`, true, locStub),
                    createSimpleExpression(`foo`, true, locStub)
                  )
                ],
                locStub
              )
            )
          ],
          // flag
          PatchFlags.FULL_PROPS + ''
        )
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
#+begin_example
--------- code ---------

return function render(_ctx, _cache) {
  with (_ctx) {
    return _createElementVNode("div", {
      id: "foo",
      [prop]: bar,
      [foo + bar]: bar
    }, [
      _createElementVNode("p", { "some-key": "foo" })
    ], 16)
  }
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details ArrayExpression :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createArrayExpression([
    createSimpleExpression(`foo`, false),
    createCallExpression(`bar`, [`baz`])
  ])
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
#+begin_example
--------- code ---------

return function render(_ctx, _cache) {
  with (_ctx) {
    return [
      foo,
      bar(baz)
    ]
  }
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details ConditionalExpression :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createConditionalExpression(
    createSimpleExpression(`ok`, false),
    createCallExpression(`foo`),
    createConditionalExpression(
      createSimpleExpression(`orNot`, false),
      createCallExpression(`bar`),
      createCallExpression(`baz`)
    )
  )
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
#+begin_example
--------- code ---------

return function render(_ctx, _cache) {
  with (_ctx) {
    return ok
      ? foo()
      : orNot
        ? bar()
        : baz()
  }
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details CacheExpression :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  cached: 1,
  codegenNode: createCacheExpression(
    1,
    createSimpleExpression(`foo`, false)
  )
}, {
  mode: 'module',
  prefixIdentifiers: true
})
const { code } = generate(root)
logg("code", code)
#+end_src

<red:with isVNode:true>

#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  cached: 1,
  codegenNode: createCacheExpression(
    1,
    createSimpleExpression(`foo`, false),
    true
  )
}, {
  mode: 'module',
  prefixIdentifiers: true
})
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
#+begin_example
--------- code ---------

return function render(_ctx, _cache) {
  with (_ctx) {
    return _cache[1] || (
      _setBlockTracking(-1),
      _cache[1] = foo,
      _setBlockTracking(1),
      _cache[1]
    )
  }
}
undefined
#+end_example
#+end_details

#+html: <br>
#+begin_details TemplateLiteral :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createCallExpression(`_push`, [
    createTemplateLiteral([
      `foo`,
      createCallExpression(`_renderAttr`, ['id', 'foo']),
      `bar`
    ])
  ])
}, { mode: 'module' })
const { code } = generate(root)
logg("code", code)
#+end_src

#+RESULTS:
: --------- code ---------
:
: return function render(_ctx, _cache) {
:   with (_ctx) {
:     return _push(`foo${_renderAttr(id, foo)}bar`)
:   }
: }
: undefined
#+end_details

#+html: <br>
#+begin_details IfStatement :title-color red

red:if

#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createBlockStatement([
    createIfStatement(
      createSimpleExpression('foo', false),
      createBlockStatement([createCallExpression(`ok`)])
    )
  ])
}, { mode: 'module' })
const { code } = generate(root)
logg("code", code)
#+end_src

red:if/else

#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createBlockStatement([
    createIfStatement(
      createSimpleExpression('foo', false),
      createBlockStatement([createCallExpression(`foo`)]),
      createBlockStatement([createCallExpression(`bar`)]),
    )
  ])
}, { mode: 'module' })
const { code } = generate(root)
logg("code", code)
#+end_src

red:if/else-if

#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createBlockStatement([
    createIfStatement(
      createSimpleExpression('foo', false),
      createBlockStatement([createCallExpression(`foo`)]),
      createIfStatement(
        createSimpleExpression('bar', false),
        createBlockStatement([createCallExpression(`bar`)])
      )
    )
  ])
}, { mode: 'module' })
const { code } = generate(root)
logg("code", code)
#+end_src

red:if/else-if/else

#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createBlockStatement([
    createIfStatement(
      createSimpleExpression('foo', false),
      createBlockStatement([createCallExpression(`foo`)]),
      createIfStatement(
        createSimpleExpression('bar', false),
        createBlockStatement([createCallExpression(`bar`)]),
        createBlockStatement([createCallExpression(`baz`)])
      )
    )
  ])
}, { mode: 'module' })
const { code } = generate(root)
logg("code", code)
#+end_src
#+end_details

#+html: <br>
#+begin_details AssignmentExpression :title-color red
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

const root = _createRoot({
  codegenNode: createAssignmentExpression(
    createSimpleExpression(`foo`, false),
    createSimpleExpression(`bar`, false)
  )
})
const { code } = generate(root)
logg("code", code)
#+end_src
#+end_details

#+html: <br>
#+begin_details VNodeCall :title-color red

#+name: VNodeCall-test-genCode
#+begin_src js -n -r :exports both
<<codegen-testing-utils>>

function _genCode(node) {
  return generate(
    _createRoot({
      codegenNode: node
    })
  ).code
}

const mockProps = createObjectExpression([
  createObjectProperty(`foo`, createSimpleExpression(`bar`, true))
])
const mockChildren = createCompoundExpression(['children'])
const mockDirs = createArrayExpression([
  createArrayExpression([`foo`, createSimpleExpression(`bar`, false)])
])

logg("tag only - div", _genCode(createVNodeCall(null, `"div"`)))
logg("tag only - FRAGMENT", _genCode(createVNodeCall(null, FRAGMENT)))

logg("with props", _genCode(createVNodeCall(null, `"div"`, mockProps)))

logg("with children, no props", _genCode(createVNodeCall(null, `"div"`, undefined, mockChildren)))
logg("with children + props", _genCode(createVNodeCall(null, `"div"`, mockProps, mockChildren)))
logg("with patchFlag and no children/props", _genCode(createVNodeCall(null, `"div"`, undefined, undefined, "1")))

logg("as block", _genCode(createVNodeCall(null, `"div"`, mockProps, mockChildren, undefined, undefined, undefined, true)))
logg("as for block", _genCode(
  createVNodeCall(
    null,
    `"div"`,
    mockProps,
    mockChildren,
    undefined,
    undefined,
    undefined,
    true,
    true
  )
))

logg("with directives", _genCode(
  createVNodeCall(
    null,
    `"div"`,
    mockProps,
    mockChildren,
    undefined,
    undefined,
    mockDirs
  )
))

logg("block + directives", _genCode(
  createVNodeCall(
    null,
    `"div"`,
    mockProps,
    mockChildren,
    undefined,
    undefined,
    mockDirs,
    true
  )
))
#+end_src
#+end_details
* compile
:PROPERTIES:
:COLUMNS:  %CUSTOM_ID[(Custom Id)]
:CUSTOM_ID: cc-compile
:END:


结合 ast parser -> transform -> codegen 使用 compile 函数将 SFC 编译成 render 函
数。

#+name: baseCompile
#+begin_src js -n -r
<<globalVars>>
<<baseParse>>
<<transform>>
<<getBaseTransformPreset>>
<<codegen>>

function baseCompile(template, options = {}) {
  const isModuleMode = options.mode === 'module'

  const prefixIdentifiers =
    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)

  const ast = isString(template) ? baseParse(template, options) : template
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers)

  // 转换出每个节点的 codegenNode
  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {} // user transforms
      )
    })
  )

  // 生成 codegen
  return generate(ast, extend({}, options, { prefixIdentifiers }))
}
#+end_src

red:Testing

#+html: <br>
#+begin_details integration tests :title-color red
#+begin_src js -n -r :exports both
<<baseCompile>>

const source = `
<div id="foo" :class="bar.baz">
  {{ world.burn() }}
  <div v-if="ok">yes</div>
  <template v-else>no</template>
  <div v-for="(value, index) in list"><span>{{ value + index }}</span></div>
</div>
`.trim()

logOff()
const { code, map } = baseCompile(source, {
  sourceMap: true,
  filename: 'foo.vue'
})
logOn()
logg('code', code)
#+end_src

#+RESULTS:
#+begin_example
--------- createStructuralDirectiveTransform ---------
name=for, matches=(n) => n === name
--------- createStructuralDirectiveTransform ---------
name=/^(if|else|else-if)$/, matches=(n) => name.test(n)
--------- code ---------
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { toDisplayString: _toDisplayString, openBlock: _openBlock, createElementBlock: _createElementBlock, createCommentVNode: _createCommentVNode, createTextVNode: _createTextVNode, Fragment: _Fragment, renderList: _renderList, createElementVNode: _createElementVNode, normalizeClass: _normalizeClass } = _Vue

    return (_openBlock(), _createElementBlock("div", {
      id: "foo",
      class: _normalizeClass(bar.baz)
    }, [
      _createTextVNode("   " + _toDisplayString(world.burn()) + "   ", 1 /* TEXT */),
      ok
        ? (_openBlock(), _createElementBlock("div", { key: 0 }, "yes"))
        : (_openBlock(), _createElementBlock(_Fragment, { key: 1 }, [
            _createTextVNode("no")
          ], 64 /* STABLE_FRAGMENT */)),
      _createTextVNode("   "),
      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(list, (value, index) => {
        return (_openBlock(), _createElementBlock("div", null, [
          _createElementVNode("span", null, _toDisplayString(value + index), 1)
        ]))
      }), 256 /* UNKEYED_FRAGMENT */))
    ], 2))
  }
}
undefined
#+end_example

#+end_details

全部代码：

#+html: <br>
#+begin_details baseCompile :title-color red
#+begin_src js -n -r :noweb yes :tangle "~/github/mine/blog.cheng92.com/assets/tests/compiler-core.js"
<<baseCompile>>
#+end_src
#+end_details
** getBaseTransformPreset()

#+name: getBaseTransformPreset
#+begin_src js -n -r
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...(!__BROWSER__ && prefixIdentifiers
        ? [
            // order is important
            trackVForSlotScopes,
            transformExpression
          ]
        : __BROWSER__ && __DEV__
        ? [transformExpression]
        : []),
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ]
}
#+end_src
** testing

测试及案例分析(含流程图)

#+begin_export html
<script src="/assets/tests/compiler-core.js"></script>
<div id="Mr9KIGir"></div>
<script src="assets/tests/Mr9KIGir.js"></script>
#+end_export

*** pure div

~<div/>~

#+begin_src js -n -r :exports both
<<baseCompile>>

logOff()
const { code } = baseCompile('<div></div>', {
  filename: 'foo.vue'
})
logOn()

logg('code', code)
#+end_src

#+RESULTS:
#+begin_example
--------- createStructuralDirectiveTransform ---------
name=for, matches=(n) => n === name
--------- createStructuralDirectiveTransform ---------
name=/^(if|else|else-if)$/, matches=(n) => name.test(n)
--------- code ---------
const _Vue = Vue

return function render(_ctx, _cache) {
  with (_ctx) {
    const { openBlock: _openBlock, createElementBlock: _createElementBlock } = _Vue

    return (_openBlock(), _createElementBlock("div"))
  }
}
undefined
#+end_example

#+begin_export html
<a href="../assets/img/vue3/compiler-core/pcg/pcg-01-pure-div.svg"
data-fancybox="gallery"
data-caption="Preview"
><img src="../assets/img/vue3/compiler-core/pcg/pcg-01-pure-div.svg"/></a>
#+end_export

* COMMENT Local Variables :ARCHIVE:
# Local Variables:
# after-save-hook: gcl/org-html-export-to-html
# End:
